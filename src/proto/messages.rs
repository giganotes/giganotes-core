// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `protos/messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct InitData {
    // message fields
    pub dataPath: ::std::string::String,
    pub apiPath: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InitData {
    fn default() -> &'a InitData {
        <InitData as ::protobuf::Message>::default_instance()
    }
}

impl InitData {
    pub fn new() -> InitData {
        ::std::default::Default::default()
    }

    // string dataPath = 1;


    pub fn get_dataPath(&self) -> &str {
        &self.dataPath
    }
    pub fn clear_dataPath(&mut self) {
        self.dataPath.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataPath(&mut self, v: ::std::string::String) {
        self.dataPath = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataPath(&mut self) -> &mut ::std::string::String {
        &mut self.dataPath
    }

    // Take field
    pub fn take_dataPath(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dataPath, ::std::string::String::new())
    }

    // string apiPath = 2;


    pub fn get_apiPath(&self) -> &str {
        &self.apiPath
    }
    pub fn clear_apiPath(&mut self) {
        self.apiPath.clear();
    }

    // Param is passed by value, moved
    pub fn set_apiPath(&mut self, v: ::std::string::String) {
        self.apiPath = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiPath(&mut self) -> &mut ::std::string::String {
        &mut self.apiPath
    }

    // Take field
    pub fn take_apiPath(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.apiPath, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InitData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dataPath)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.apiPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dataPath.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataPath);
        }
        if !self.apiPath.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.apiPath);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dataPath.is_empty() {
            os.write_string(1, &self.dataPath)?;
        }
        if !self.apiPath.is_empty() {
            os.write_string(2, &self.apiPath)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InitData {
        InitData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataPath",
                |m: &InitData| { &m.dataPath },
                |m: &mut InitData| { &mut m.dataPath },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "apiPath",
                |m: &InitData| { &m.apiPath },
                |m: &mut InitData| { &mut m.apiPath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InitData>(
                "InitData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InitData {
        static instance: ::protobuf::rt::LazyV2<InitData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InitData::new)
    }
}

impl ::protobuf::Clear for InitData {
    fn clear(&mut self) {
        self.dataPath.clear();
        self.apiPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InitData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Login {
    // message fields
    pub email: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Login {
    fn default() -> &'a Login {
        <Login as ::protobuf::Message>::default_instance()
    }
}

impl Login {
    pub fn new() -> Login {
        ::std::default::Default::default()
    }

    // string email = 1;


    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Login {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.email)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.email);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.email.is_empty() {
            os.write_string(1, &self.email)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Login {
        Login::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email",
                |m: &Login| { &m.email },
                |m: &mut Login| { &mut m.email },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &Login| { &m.password },
                |m: &mut Login| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Login>(
                "Login",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Login {
        static instance: ::protobuf::rt::LazyV2<Login> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Login::new)
    }
}

impl ::protobuf::Clear for Login {
    fn clear(&mut self) {
        self.email.clear();
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Login {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Login {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoginResponse {
    // message fields
    pub success: bool,
    pub errorCode: i32,
    pub token: ::std::string::String,
    pub userId: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoginResponse {
    fn default() -> &'a LoginResponse {
        <LoginResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoginResponse {
    pub fn new() -> LoginResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 errorCode = 2;


    pub fn get_errorCode(&self) -> i32 {
        self.errorCode
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: i32) {
        self.errorCode = v;
    }

    // string token = 3;


    pub fn get_token(&self) -> &str {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }

    // int32 userId = 4;


    pub fn get_userId(&self) -> i32 {
        self.userId
    }
    pub fn clear_userId(&mut self) {
        self.userId = 0;
    }

    // Param is passed by value, moved
    pub fn set_userId(&mut self, v: i32) {
        self.userId = v;
    }
}

impl ::protobuf::Message for LoginResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.userId = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::value_size(2, self.errorCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.token);
        }
        if self.userId != 0 {
            my_size += ::protobuf::rt::value_size(4, self.userId, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.token.is_empty() {
            os.write_string(3, &self.token)?;
        }
        if self.userId != 0 {
            os.write_int32(4, self.userId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoginResponse {
        LoginResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &LoginResponse| { &m.success },
                |m: &mut LoginResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorCode",
                |m: &LoginResponse| { &m.errorCode },
                |m: &mut LoginResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &LoginResponse| { &m.token },
                |m: &mut LoginResponse| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "userId",
                |m: &LoginResponse| { &m.userId },
                |m: &mut LoginResponse| { &mut m.userId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoginResponse>(
                "LoginResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoginResponse {
        static instance: ::protobuf::rt::LazyV2<LoginResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoginResponse::new)
    }
}

impl ::protobuf::Clear for LoginResponse {
    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.token.clear();
        self.userId = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateNote {
    // message fields
    pub title: ::std::string::String,
    pub text: ::std::string::String,
    pub folderId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateNote {
    fn default() -> &'a CreateNote {
        <CreateNote as ::protobuf::Message>::default_instance()
    }
}

impl CreateNote {
    pub fn new() -> CreateNote {
        ::std::default::Default::default()
    }

    // string title = 1;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string text = 2;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }

    // string folderId = 3;


    pub fn get_folderId(&self) -> &str {
        &self.folderId
    }
    pub fn clear_folderId(&mut self) {
        self.folderId.clear();
    }

    // Param is passed by value, moved
    pub fn set_folderId(&mut self, v: ::std::string::String) {
        self.folderId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folderId(&mut self) -> &mut ::std::string::String {
        &mut self.folderId
    }

    // Take field
    pub fn take_folderId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.folderId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateNote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.folderId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.text);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.text.is_empty() {
            os.write_string(2, &self.text)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(3, &self.folderId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateNote {
        CreateNote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &CreateNote| { &m.title },
                |m: &mut CreateNote| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &CreateNote| { &m.text },
                |m: &mut CreateNote| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folderId",
                |m: &CreateNote| { &m.folderId },
                |m: &mut CreateNote| { &mut m.folderId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateNote>(
                "CreateNote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateNote {
        static instance: ::protobuf::rt::LazyV2<CreateNote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateNote::new)
    }
}

impl ::protobuf::Clear for CreateNote {
    fn clear(&mut self) {
        self.title.clear();
        self.text.clear();
        self.folderId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateNote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateNote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateFolder {
    // message fields
    pub parentId: ::std::string::String,
    pub title: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateFolder {
    fn default() -> &'a CreateFolder {
        <CreateFolder as ::protobuf::Message>::default_instance()
    }
}

impl CreateFolder {
    pub fn new() -> CreateFolder {
        ::std::default::Default::default()
    }

    // string parentId = 1;


    pub fn get_parentId(&self) -> &str {
        &self.parentId
    }
    pub fn clear_parentId(&mut self) {
        self.parentId.clear();
    }

    // Param is passed by value, moved
    pub fn set_parentId(&mut self, v: ::std::string::String) {
        self.parentId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentId(&mut self) -> &mut ::std::string::String {
        &mut self.parentId
    }

    // Take field
    pub fn take_parentId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parentId, ::std::string::String::new())
    }

    // string title = 2;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateFolder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parentId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parentId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parentId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parentId.is_empty() {
            os.write_string(1, &self.parentId)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateFolder {
        CreateFolder::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentId",
                |m: &CreateFolder| { &m.parentId },
                |m: &mut CreateFolder| { &mut m.parentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &CreateFolder| { &m.title },
                |m: &mut CreateFolder| { &mut m.title },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateFolder>(
                "CreateFolder",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateFolder {
        static instance: ::protobuf::rt::LazyV2<CreateFolder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateFolder::new)
    }
}

impl ::protobuf::Clear for CreateFolder {
    fn clear(&mut self) {
        self.parentId.clear();
        self.title.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateFolder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFolder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateFolderResponse {
    // message fields
    pub success: bool,
    pub errorCode: i32,
    pub folderId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateFolderResponse {
    fn default() -> &'a CreateFolderResponse {
        <CreateFolderResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateFolderResponse {
    pub fn new() -> CreateFolderResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 errorCode = 2;


    pub fn get_errorCode(&self) -> i32 {
        self.errorCode
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: i32) {
        self.errorCode = v;
    }

    // string folderId = 3;


    pub fn get_folderId(&self) -> &str {
        &self.folderId
    }
    pub fn clear_folderId(&mut self) {
        self.folderId.clear();
    }

    // Param is passed by value, moved
    pub fn set_folderId(&mut self, v: ::std::string::String) {
        self.folderId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folderId(&mut self) -> &mut ::std::string::String {
        &mut self.folderId
    }

    // Take field
    pub fn take_folderId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.folderId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateFolderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.folderId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::value_size(2, self.errorCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(3, &self.folderId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateFolderResponse {
        CreateFolderResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &CreateFolderResponse| { &m.success },
                |m: &mut CreateFolderResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorCode",
                |m: &CreateFolderResponse| { &m.errorCode },
                |m: &mut CreateFolderResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folderId",
                |m: &CreateFolderResponse| { &m.folderId },
                |m: &mut CreateFolderResponse| { &mut m.folderId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateFolderResponse>(
                "CreateFolderResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateFolderResponse {
        static instance: ::protobuf::rt::LazyV2<CreateFolderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateFolderResponse::new)
    }
}

impl ::protobuf::Clear for CreateFolderResponse {
    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.folderId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateFolderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFolderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateNoteResponse {
    // message fields
    pub success: bool,
    pub errorCode: i32,
    pub noteId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateNoteResponse {
    fn default() -> &'a CreateNoteResponse {
        <CreateNoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateNoteResponse {
    pub fn new() -> CreateNoteResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 errorCode = 2;


    pub fn get_errorCode(&self) -> i32 {
        self.errorCode
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: i32) {
        self.errorCode = v;
    }

    // string noteId = 3;


    pub fn get_noteId(&self) -> &str {
        &self.noteId
    }
    pub fn clear_noteId(&mut self) {
        self.noteId.clear();
    }

    // Param is passed by value, moved
    pub fn set_noteId(&mut self, v: ::std::string::String) {
        self.noteId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_noteId(&mut self) -> &mut ::std::string::String {
        &mut self.noteId
    }

    // Take field
    pub fn take_noteId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.noteId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateNoteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.noteId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::value_size(2, self.errorCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.noteId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.noteId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.noteId.is_empty() {
            os.write_string(3, &self.noteId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateNoteResponse {
        CreateNoteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &CreateNoteResponse| { &m.success },
                |m: &mut CreateNoteResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorCode",
                |m: &CreateNoteResponse| { &m.errorCode },
                |m: &mut CreateNoteResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "noteId",
                |m: &CreateNoteResponse| { &m.noteId },
                |m: &mut CreateNoteResponse| { &mut m.noteId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateNoteResponse>(
                "CreateNoteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateNoteResponse {
        static instance: ::protobuf::rt::LazyV2<CreateNoteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateNoteResponse::new)
    }
}

impl ::protobuf::Clear for CreateNoteResponse {
    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.noteId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateNoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateNoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNotesList {
    // message fields
    pub folderId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNotesList {
    fn default() -> &'a GetNotesList {
        <GetNotesList as ::protobuf::Message>::default_instance()
    }
}

impl GetNotesList {
    pub fn new() -> GetNotesList {
        ::std::default::Default::default()
    }

    // string folderId = 1;


    pub fn get_folderId(&self) -> &str {
        &self.folderId
    }
    pub fn clear_folderId(&mut self) {
        self.folderId.clear();
    }

    // Param is passed by value, moved
    pub fn set_folderId(&mut self, v: ::std::string::String) {
        self.folderId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folderId(&mut self) -> &mut ::std::string::String {
        &mut self.folderId
    }

    // Take field
    pub fn take_folderId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.folderId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetNotesList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.folderId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.folderId.is_empty() {
            os.write_string(1, &self.folderId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNotesList {
        GetNotesList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folderId",
                |m: &GetNotesList| { &m.folderId },
                |m: &mut GetNotesList| { &mut m.folderId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetNotesList>(
                "GetNotesList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetNotesList {
        static instance: ::protobuf::rt::LazyV2<GetNotesList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetNotesList::new)
    }
}

impl ::protobuf::Clear for GetNotesList {
    fn clear(&mut self) {
        self.folderId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNotesList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNotesList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAllNotes {
    // message fields
    pub offset: i32,
    pub limit: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAllNotes {
    fn default() -> &'a GetAllNotes {
        <GetAllNotes as ::protobuf::Message>::default_instance()
    }
}

impl GetAllNotes {
    pub fn new() -> GetAllNotes {
        ::std::default::Default::default()
    }

    // int32 offset = 1;


    pub fn get_offset(&self) -> i32 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i32) {
        self.offset = v;
    }

    // int32 limit = 2;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }
}

impl ::protobuf::Message for GetAllNotes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offset = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(1, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.offset != 0 {
            os.write_int32(1, self.offset)?;
        }
        if self.limit != 0 {
            os.write_int32(2, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAllNotes {
        GetAllNotes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offset",
                |m: &GetAllNotes| { &m.offset },
                |m: &mut GetAllNotes| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "limit",
                |m: &GetAllNotes| { &m.limit },
                |m: &mut GetAllNotes| { &mut m.limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAllNotes>(
                "GetAllNotes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAllNotes {
        static instance: ::protobuf::rt::LazyV2<GetAllNotes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAllNotes::new)
    }
}

impl ::protobuf::Clear for GetAllNotes {
    fn clear(&mut self) {
        self.offset = 0;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAllNotes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllNotes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetToken {
    // message fields
    pub token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetToken {
    fn default() -> &'a SetToken {
        <SetToken as ::protobuf::Message>::default_instance()
    }
}

impl SetToken {
    pub fn new() -> SetToken {
        ::std::default::Default::default()
    }

    // string token = 1;


    pub fn get_token(&self) -> &str {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.token.is_empty() {
            os.write_string(1, &self.token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetToken {
        SetToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &SetToken| { &m.token },
                |m: &mut SetToken| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetToken>(
                "SetToken",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetToken {
        static instance: ::protobuf::rt::LazyV2<SetToken> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetToken::new)
    }
}

impl ::protobuf::Clear for SetToken {
    fn clear(&mut self) {
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetToken {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NoteShortInfo {
    // message fields
    pub id: ::std::string::String,
    pub folderId: ::std::string::String,
    pub title: ::std::string::String,
    pub createdAt: i64,
    pub updatedAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NoteShortInfo {
    fn default() -> &'a NoteShortInfo {
        <NoteShortInfo as ::protobuf::Message>::default_instance()
    }
}

impl NoteShortInfo {
    pub fn new() -> NoteShortInfo {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string folderId = 2;


    pub fn get_folderId(&self) -> &str {
        &self.folderId
    }
    pub fn clear_folderId(&mut self) {
        self.folderId.clear();
    }

    // Param is passed by value, moved
    pub fn set_folderId(&mut self, v: ::std::string::String) {
        self.folderId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folderId(&mut self) -> &mut ::std::string::String {
        &mut self.folderId
    }

    // Take field
    pub fn take_folderId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.folderId, ::std::string::String::new())
    }

    // string title = 3;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // int64 createdAt = 4;


    pub fn get_createdAt(&self) -> i64 {
        self.createdAt
    }
    pub fn clear_createdAt(&mut self) {
        self.createdAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: i64) {
        self.createdAt = v;
    }

    // int64 updatedAt = 5;


    pub fn get_updatedAt(&self) -> i64 {
        self.updatedAt
    }
    pub fn clear_updatedAt(&mut self) {
        self.updatedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_updatedAt(&mut self, v: i64) {
        self.updatedAt = v;
    }
}

impl ::protobuf::Message for NoteShortInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.folderId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createdAt = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.updatedAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.folderId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.title);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::value_size(4, self.createdAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::value_size(5, self.updatedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(2, &self.folderId)?;
        }
        if !self.title.is_empty() {
            os.write_string(3, &self.title)?;
        }
        if self.createdAt != 0 {
            os.write_int64(4, self.createdAt)?;
        }
        if self.updatedAt != 0 {
            os.write_int64(5, self.updatedAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NoteShortInfo {
        NoteShortInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &NoteShortInfo| { &m.id },
                |m: &mut NoteShortInfo| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folderId",
                |m: &NoteShortInfo| { &m.folderId },
                |m: &mut NoteShortInfo| { &mut m.folderId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &NoteShortInfo| { &m.title },
                |m: &mut NoteShortInfo| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "createdAt",
                |m: &NoteShortInfo| { &m.createdAt },
                |m: &mut NoteShortInfo| { &mut m.createdAt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "updatedAt",
                |m: &NoteShortInfo| { &m.updatedAt },
                |m: &mut NoteShortInfo| { &mut m.updatedAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NoteShortInfo>(
                "NoteShortInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NoteShortInfo {
        static instance: ::protobuf::rt::LazyV2<NoteShortInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NoteShortInfo::new)
    }
}

impl ::protobuf::Clear for NoteShortInfo {
    fn clear(&mut self) {
        self.id.clear();
        self.folderId.clear();
        self.title.clear();
        self.createdAt = 0;
        self.updatedAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NoteShortInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoteShortInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNotesListResponse {
    // message fields
    pub success: bool,
    pub errorCode: i32,
    pub notes: ::protobuf::RepeatedField<NoteShortInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNotesListResponse {
    fn default() -> &'a GetNotesListResponse {
        <GetNotesListResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetNotesListResponse {
    pub fn new() -> GetNotesListResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 errorCode = 2;


    pub fn get_errorCode(&self) -> i32 {
        self.errorCode
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: i32) {
        self.errorCode = v;
    }

    // repeated .gigamessages.NoteShortInfo notes = 3;


    pub fn get_notes(&self) -> &[NoteShortInfo] {
        &self.notes
    }
    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::protobuf::RepeatedField<NoteShortInfo>) {
        self.notes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notes(&mut self) -> &mut ::protobuf::RepeatedField<NoteShortInfo> {
        &mut self.notes
    }

    // Take field
    pub fn take_notes(&mut self) -> ::protobuf::RepeatedField<NoteShortInfo> {
        ::std::mem::replace(&mut self.notes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetNotesListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.notes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::value_size(2, self.errorCode, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.notes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        for v in &self.notes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNotesListResponse {
        GetNotesListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &GetNotesListResponse| { &m.success },
                |m: &mut GetNotesListResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorCode",
                |m: &GetNotesListResponse| { &m.errorCode },
                |m: &mut GetNotesListResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NoteShortInfo>>(
                "notes",
                |m: &GetNotesListResponse| { &m.notes },
                |m: &mut GetNotesListResponse| { &mut m.notes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetNotesListResponse>(
                "GetNotesListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetNotesListResponse {
        static instance: ::protobuf::rt::LazyV2<GetNotesListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetNotesListResponse::new)
    }
}

impl ::protobuf::Clear for GetNotesListResponse {
    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.notes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNotesListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNotesListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Folder {
    // message fields
    pub id: ::std::string::String,
    pub parentId: ::std::string::String,
    pub title: ::std::string::String,
    pub level: i32,
    pub createdAt: i64,
    pub updatedAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Folder {
    fn default() -> &'a Folder {
        <Folder as ::protobuf::Message>::default_instance()
    }
}

impl Folder {
    pub fn new() -> Folder {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string parentId = 2;


    pub fn get_parentId(&self) -> &str {
        &self.parentId
    }
    pub fn clear_parentId(&mut self) {
        self.parentId.clear();
    }

    // Param is passed by value, moved
    pub fn set_parentId(&mut self, v: ::std::string::String) {
        self.parentId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentId(&mut self) -> &mut ::std::string::String {
        &mut self.parentId
    }

    // Take field
    pub fn take_parentId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parentId, ::std::string::String::new())
    }

    // string title = 3;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // int32 level = 4;


    pub fn get_level(&self) -> i32 {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = 0;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: i32) {
        self.level = v;
    }

    // int64 createdAt = 5;


    pub fn get_createdAt(&self) -> i64 {
        self.createdAt
    }
    pub fn clear_createdAt(&mut self) {
        self.createdAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: i64) {
        self.createdAt = v;
    }

    // int64 updatedAt = 6;


    pub fn get_updatedAt(&self) -> i64 {
        self.updatedAt
    }
    pub fn clear_updatedAt(&mut self) {
        self.updatedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_updatedAt(&mut self, v: i64) {
        self.updatedAt = v;
    }
}

impl ::protobuf::Message for Folder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parentId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.level = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createdAt = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.updatedAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.parentId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.parentId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.title);
        }
        if self.level != 0 {
            my_size += ::protobuf::rt::value_size(4, self.level, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::value_size(5, self.createdAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::value_size(6, self.updatedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.parentId.is_empty() {
            os.write_string(2, &self.parentId)?;
        }
        if !self.title.is_empty() {
            os.write_string(3, &self.title)?;
        }
        if self.level != 0 {
            os.write_int32(4, self.level)?;
        }
        if self.createdAt != 0 {
            os.write_int64(5, self.createdAt)?;
        }
        if self.updatedAt != 0 {
            os.write_int64(6, self.updatedAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Folder {
        Folder::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Folder| { &m.id },
                |m: &mut Folder| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentId",
                |m: &Folder| { &m.parentId },
                |m: &mut Folder| { &mut m.parentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &Folder| { &m.title },
                |m: &mut Folder| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "level",
                |m: &Folder| { &m.level },
                |m: &mut Folder| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "createdAt",
                |m: &Folder| { &m.createdAt },
                |m: &mut Folder| { &mut m.createdAt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "updatedAt",
                |m: &Folder| { &m.updatedAt },
                |m: &mut Folder| { &mut m.updatedAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Folder>(
                "Folder",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Folder {
        static instance: ::protobuf::rt::LazyV2<Folder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Folder::new)
    }
}

impl ::protobuf::Clear for Folder {
    fn clear(&mut self) {
        self.id.clear();
        self.parentId.clear();
        self.title.clear();
        self.level = 0;
        self.createdAt = 0;
        self.updatedAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Folder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Folder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFoldersListResponse {
    // message fields
    pub success: bool,
    pub errorCode: i32,
    pub folders: ::protobuf::RepeatedField<Folder>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFoldersListResponse {
    fn default() -> &'a GetFoldersListResponse {
        <GetFoldersListResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFoldersListResponse {
    pub fn new() -> GetFoldersListResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 errorCode = 2;


    pub fn get_errorCode(&self) -> i32 {
        self.errorCode
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: i32) {
        self.errorCode = v;
    }

    // repeated .gigamessages.Folder folders = 3;


    pub fn get_folders(&self) -> &[Folder] {
        &self.folders
    }
    pub fn clear_folders(&mut self) {
        self.folders.clear();
    }

    // Param is passed by value, moved
    pub fn set_folders(&mut self, v: ::protobuf::RepeatedField<Folder>) {
        self.folders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_folders(&mut self) -> &mut ::protobuf::RepeatedField<Folder> {
        &mut self.folders
    }

    // Take field
    pub fn take_folders(&mut self) -> ::protobuf::RepeatedField<Folder> {
        ::std::mem::replace(&mut self.folders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetFoldersListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.folders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.folders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::value_size(2, self.errorCode, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.folders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        for v in &self.folders {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFoldersListResponse {
        GetFoldersListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &GetFoldersListResponse| { &m.success },
                |m: &mut GetFoldersListResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorCode",
                |m: &GetFoldersListResponse| { &m.errorCode },
                |m: &mut GetFoldersListResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Folder>>(
                "folders",
                |m: &GetFoldersListResponse| { &m.folders },
                |m: &mut GetFoldersListResponse| { &mut m.folders },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFoldersListResponse>(
                "GetFoldersListResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFoldersListResponse {
        static instance: ::protobuf::rt::LazyV2<GetFoldersListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFoldersListResponse::new)
    }
}

impl ::protobuf::Clear for GetFoldersListResponse {
    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.folders.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFoldersListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFoldersListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNoteById {
    // message fields
    pub noteId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNoteById {
    fn default() -> &'a GetNoteById {
        <GetNoteById as ::protobuf::Message>::default_instance()
    }
}

impl GetNoteById {
    pub fn new() -> GetNoteById {
        ::std::default::Default::default()
    }

    // string noteId = 1;


    pub fn get_noteId(&self) -> &str {
        &self.noteId
    }
    pub fn clear_noteId(&mut self) {
        self.noteId.clear();
    }

    // Param is passed by value, moved
    pub fn set_noteId(&mut self, v: ::std::string::String) {
        self.noteId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_noteId(&mut self) -> &mut ::std::string::String {
        &mut self.noteId
    }

    // Take field
    pub fn take_noteId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.noteId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetNoteById {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.noteId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.noteId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.noteId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.noteId.is_empty() {
            os.write_string(1, &self.noteId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNoteById {
        GetNoteById::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "noteId",
                |m: &GetNoteById| { &m.noteId },
                |m: &mut GetNoteById| { &mut m.noteId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetNoteById>(
                "GetNoteById",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetNoteById {
        static instance: ::protobuf::rt::LazyV2<GetNoteById> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetNoteById::new)
    }
}

impl ::protobuf::Clear for GetNoteById {
    fn clear(&mut self) {
        self.noteId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNoteById {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNoteById {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNoteByIdResponse {
    // message fields
    pub success: bool,
    pub errorCode: i32,
    pub id: ::std::string::String,
    pub folderId: ::std::string::String,
    pub title: ::std::string::String,
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNoteByIdResponse {
    fn default() -> &'a GetNoteByIdResponse {
        <GetNoteByIdResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetNoteByIdResponse {
    pub fn new() -> GetNoteByIdResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 errorCode = 2;


    pub fn get_errorCode(&self) -> i32 {
        self.errorCode
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: i32) {
        self.errorCode = v;
    }

    // string id = 3;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string folderId = 4;


    pub fn get_folderId(&self) -> &str {
        &self.folderId
    }
    pub fn clear_folderId(&mut self) {
        self.folderId.clear();
    }

    // Param is passed by value, moved
    pub fn set_folderId(&mut self, v: ::std::string::String) {
        self.folderId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folderId(&mut self) -> &mut ::std::string::String {
        &mut self.folderId
    }

    // Take field
    pub fn take_folderId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.folderId, ::std::string::String::new())
    }

    // string title = 5;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string text = 6;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetNoteByIdResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.folderId)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::value_size(2, self.errorCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.folderId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.title);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(4, &self.folderId)?;
        }
        if !self.title.is_empty() {
            os.write_string(5, &self.title)?;
        }
        if !self.text.is_empty() {
            os.write_string(6, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNoteByIdResponse {
        GetNoteByIdResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &GetNoteByIdResponse| { &m.success },
                |m: &mut GetNoteByIdResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorCode",
                |m: &GetNoteByIdResponse| { &m.errorCode },
                |m: &mut GetNoteByIdResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetNoteByIdResponse| { &m.id },
                |m: &mut GetNoteByIdResponse| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folderId",
                |m: &GetNoteByIdResponse| { &m.folderId },
                |m: &mut GetNoteByIdResponse| { &mut m.folderId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &GetNoteByIdResponse| { &m.title },
                |m: &mut GetNoteByIdResponse| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &GetNoteByIdResponse| { &m.text },
                |m: &mut GetNoteByIdResponse| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetNoteByIdResponse>(
                "GetNoteByIdResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetNoteByIdResponse {
        static instance: ::protobuf::rt::LazyV2<GetNoteByIdResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetNoteByIdResponse::new)
    }
}

impl ::protobuf::Clear for GetNoteByIdResponse {
    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.id.clear();
        self.folderId.clear();
        self.title.clear();
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNoteByIdResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNoteByIdResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFolderById {
    // message fields
    pub folderId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFolderById {
    fn default() -> &'a GetFolderById {
        <GetFolderById as ::protobuf::Message>::default_instance()
    }
}

impl GetFolderById {
    pub fn new() -> GetFolderById {
        ::std::default::Default::default()
    }

    // string folderId = 1;


    pub fn get_folderId(&self) -> &str {
        &self.folderId
    }
    pub fn clear_folderId(&mut self) {
        self.folderId.clear();
    }

    // Param is passed by value, moved
    pub fn set_folderId(&mut self, v: ::std::string::String) {
        self.folderId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folderId(&mut self) -> &mut ::std::string::String {
        &mut self.folderId
    }

    // Take field
    pub fn take_folderId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.folderId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFolderById {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.folderId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.folderId.is_empty() {
            os.write_string(1, &self.folderId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFolderById {
        GetFolderById::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folderId",
                |m: &GetFolderById| { &m.folderId },
                |m: &mut GetFolderById| { &mut m.folderId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFolderById>(
                "GetFolderById",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFolderById {
        static instance: ::protobuf::rt::LazyV2<GetFolderById> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFolderById::new)
    }
}

impl ::protobuf::Clear for GetFolderById {
    fn clear(&mut self) {
        self.folderId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFolderById {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFolderById {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFolderByIdResponse {
    // message fields
    pub success: bool,
    pub errorCode: i32,
    pub id: ::std::string::String,
    pub title: ::std::string::String,
    pub parentId: ::std::string::String,
    pub level: i32,
    pub createdAt: i64,
    pub updatedAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFolderByIdResponse {
    fn default() -> &'a GetFolderByIdResponse {
        <GetFolderByIdResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFolderByIdResponse {
    pub fn new() -> GetFolderByIdResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 errorCode = 2;


    pub fn get_errorCode(&self) -> i32 {
        self.errorCode
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: i32) {
        self.errorCode = v;
    }

    // string id = 3;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string title = 4;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string parentId = 5;


    pub fn get_parentId(&self) -> &str {
        &self.parentId
    }
    pub fn clear_parentId(&mut self) {
        self.parentId.clear();
    }

    // Param is passed by value, moved
    pub fn set_parentId(&mut self, v: ::std::string::String) {
        self.parentId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentId(&mut self) -> &mut ::std::string::String {
        &mut self.parentId
    }

    // Take field
    pub fn take_parentId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parentId, ::std::string::String::new())
    }

    // int32 level = 6;


    pub fn get_level(&self) -> i32 {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = 0;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: i32) {
        self.level = v;
    }

    // int64 createdAt = 7;


    pub fn get_createdAt(&self) -> i64 {
        self.createdAt
    }
    pub fn clear_createdAt(&mut self) {
        self.createdAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: i64) {
        self.createdAt = v;
    }

    // int64 updatedAt = 8;


    pub fn get_updatedAt(&self) -> i64 {
        self.updatedAt
    }
    pub fn clear_updatedAt(&mut self) {
        self.updatedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_updatedAt(&mut self, v: i64) {
        self.updatedAt = v;
    }
}

impl ::protobuf::Message for GetFolderByIdResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parentId)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.level = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createdAt = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.updatedAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::value_size(2, self.errorCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.title);
        }
        if !self.parentId.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.parentId);
        }
        if self.level != 0 {
            my_size += ::protobuf::rt::value_size(6, self.level, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::value_size(7, self.createdAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::value_size(8, self.updatedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        if !self.title.is_empty() {
            os.write_string(4, &self.title)?;
        }
        if !self.parentId.is_empty() {
            os.write_string(5, &self.parentId)?;
        }
        if self.level != 0 {
            os.write_int32(6, self.level)?;
        }
        if self.createdAt != 0 {
            os.write_int64(7, self.createdAt)?;
        }
        if self.updatedAt != 0 {
            os.write_int64(8, self.updatedAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFolderByIdResponse {
        GetFolderByIdResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &GetFolderByIdResponse| { &m.success },
                |m: &mut GetFolderByIdResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorCode",
                |m: &GetFolderByIdResponse| { &m.errorCode },
                |m: &mut GetFolderByIdResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetFolderByIdResponse| { &m.id },
                |m: &mut GetFolderByIdResponse| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &GetFolderByIdResponse| { &m.title },
                |m: &mut GetFolderByIdResponse| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentId",
                |m: &GetFolderByIdResponse| { &m.parentId },
                |m: &mut GetFolderByIdResponse| { &mut m.parentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "level",
                |m: &GetFolderByIdResponse| { &m.level },
                |m: &mut GetFolderByIdResponse| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "createdAt",
                |m: &GetFolderByIdResponse| { &m.createdAt },
                |m: &mut GetFolderByIdResponse| { &mut m.createdAt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "updatedAt",
                |m: &GetFolderByIdResponse| { &m.updatedAt },
                |m: &mut GetFolderByIdResponse| { &mut m.updatedAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetFolderByIdResponse>(
                "GetFolderByIdResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetFolderByIdResponse {
        static instance: ::protobuf::rt::LazyV2<GetFolderByIdResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFolderByIdResponse::new)
    }
}

impl ::protobuf::Clear for GetFolderByIdResponse {
    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.id.clear();
        self.title.clear();
        self.parentId.clear();
        self.level = 0;
        self.createdAt = 0;
        self.updatedAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFolderByIdResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFolderByIdResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveNote {
    // message fields
    pub noteId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveNote {
    fn default() -> &'a RemoveNote {
        <RemoveNote as ::protobuf::Message>::default_instance()
    }
}

impl RemoveNote {
    pub fn new() -> RemoveNote {
        ::std::default::Default::default()
    }

    // string noteId = 1;


    pub fn get_noteId(&self) -> &str {
        &self.noteId
    }
    pub fn clear_noteId(&mut self) {
        self.noteId.clear();
    }

    // Param is passed by value, moved
    pub fn set_noteId(&mut self, v: ::std::string::String) {
        self.noteId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_noteId(&mut self) -> &mut ::std::string::String {
        &mut self.noteId
    }

    // Take field
    pub fn take_noteId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.noteId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoveNote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.noteId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.noteId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.noteId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.noteId.is_empty() {
            os.write_string(1, &self.noteId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveNote {
        RemoveNote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "noteId",
                |m: &RemoveNote| { &m.noteId },
                |m: &mut RemoveNote| { &mut m.noteId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveNote>(
                "RemoveNote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveNote {
        static instance: ::protobuf::rt::LazyV2<RemoveNote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveNote::new)
    }
}

impl ::protobuf::Clear for RemoveNote {
    fn clear(&mut self) {
        self.noteId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveNote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveNote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveFolder {
    // message fields
    pub folderId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveFolder {
    fn default() -> &'a RemoveFolder {
        <RemoveFolder as ::protobuf::Message>::default_instance()
    }
}

impl RemoveFolder {
    pub fn new() -> RemoveFolder {
        ::std::default::Default::default()
    }

    // string folderId = 1;


    pub fn get_folderId(&self) -> &str {
        &self.folderId
    }
    pub fn clear_folderId(&mut self) {
        self.folderId.clear();
    }

    // Param is passed by value, moved
    pub fn set_folderId(&mut self, v: ::std::string::String) {
        self.folderId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folderId(&mut self) -> &mut ::std::string::String {
        &mut self.folderId
    }

    // Take field
    pub fn take_folderId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.folderId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoveFolder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.folderId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.folderId.is_empty() {
            os.write_string(1, &self.folderId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveFolder {
        RemoveFolder::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folderId",
                |m: &RemoveFolder| { &m.folderId },
                |m: &mut RemoveFolder| { &mut m.folderId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoveFolder>(
                "RemoveFolder",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoveFolder {
        static instance: ::protobuf::rt::LazyV2<RemoveFolder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveFolder::new)
    }
}

impl ::protobuf::Clear for RemoveFolder {
    fn clear(&mut self) {
        self.folderId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveFolder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveFolder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRootFolderResponse {
    // message fields
    pub success: bool,
    pub errorCode: i32,
    pub folderId: ::std::string::String,
    pub title: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRootFolderResponse {
    fn default() -> &'a GetRootFolderResponse {
        <GetRootFolderResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetRootFolderResponse {
    pub fn new() -> GetRootFolderResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 errorCode = 2;


    pub fn get_errorCode(&self) -> i32 {
        self.errorCode
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: i32) {
        self.errorCode = v;
    }

    // string folderId = 3;


    pub fn get_folderId(&self) -> &str {
        &self.folderId
    }
    pub fn clear_folderId(&mut self) {
        self.folderId.clear();
    }

    // Param is passed by value, moved
    pub fn set_folderId(&mut self, v: ::std::string::String) {
        self.folderId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folderId(&mut self) -> &mut ::std::string::String {
        &mut self.folderId
    }

    // Take field
    pub fn take_folderId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.folderId, ::std::string::String::new())
    }

    // string title = 5;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetRootFolderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.folderId)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::value_size(2, self.errorCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.folderId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.title);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(3, &self.folderId)?;
        }
        if !self.title.is_empty() {
            os.write_string(5, &self.title)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRootFolderResponse {
        GetRootFolderResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &GetRootFolderResponse| { &m.success },
                |m: &mut GetRootFolderResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorCode",
                |m: &GetRootFolderResponse| { &m.errorCode },
                |m: &mut GetRootFolderResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folderId",
                |m: &GetRootFolderResponse| { &m.folderId },
                |m: &mut GetRootFolderResponse| { &mut m.folderId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &GetRootFolderResponse| { &m.title },
                |m: &mut GetRootFolderResponse| { &mut m.title },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetRootFolderResponse>(
                "GetRootFolderResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetRootFolderResponse {
        static instance: ::protobuf::rt::LazyV2<GetRootFolderResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRootFolderResponse::new)
    }
}

impl ::protobuf::Clear for GetRootFolderResponse {
    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.folderId.clear();
        self.title.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRootFolderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRootFolderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EmptyResultResponse {
    // message fields
    pub success: bool,
    pub errorCode: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EmptyResultResponse {
    fn default() -> &'a EmptyResultResponse {
        <EmptyResultResponse as ::protobuf::Message>::default_instance()
    }
}

impl EmptyResultResponse {
    pub fn new() -> EmptyResultResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 errorCode = 2;


    pub fn get_errorCode(&self) -> i32 {
        self.errorCode
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: i32) {
        self.errorCode = v;
    }
}

impl ::protobuf::Message for EmptyResultResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::value_size(2, self.errorCode, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EmptyResultResponse {
        EmptyResultResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &EmptyResultResponse| { &m.success },
                |m: &mut EmptyResultResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorCode",
                |m: &EmptyResultResponse| { &m.errorCode },
                |m: &mut EmptyResultResponse| { &mut m.errorCode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EmptyResultResponse>(
                "EmptyResultResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EmptyResultResponse {
        static instance: ::protobuf::rt::LazyV2<EmptyResultResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EmptyResultResponse::new)
    }
}

impl ::protobuf::Clear for EmptyResultResponse {
    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmptyResultResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmptyResultResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLastLoginDataResponse {
    // message fields
    pub success: bool,
    pub errorCode: i32,
    pub token: ::std::string::String,
    pub userId: i32,
    pub email: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLastLoginDataResponse {
    fn default() -> &'a GetLastLoginDataResponse {
        <GetLastLoginDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLastLoginDataResponse {
    pub fn new() -> GetLastLoginDataResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 errorCode = 2;


    pub fn get_errorCode(&self) -> i32 {
        self.errorCode
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = 0;
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: i32) {
        self.errorCode = v;
    }

    // string token = 3;


    pub fn get_token(&self) -> &str {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }

    // int32 userId = 4;


    pub fn get_userId(&self) -> i32 {
        self.userId
    }
    pub fn clear_userId(&mut self) {
        self.userId = 0;
    }

    // Param is passed by value, moved
    pub fn set_userId(&mut self, v: i32) {
        self.userId = v;
    }

    // string email = 5;


    pub fn get_email(&self) -> &str {
        &self.email
    }
    pub fn clear_email(&mut self) {
        self.email.clear();
    }

    // Param is passed by value, moved
    pub fn set_email(&mut self, v: ::std::string::String) {
        self.email = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email(&mut self) -> &mut ::std::string::String {
        &mut self.email
    }

    // Take field
    pub fn take_email(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetLastLoginDataResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.errorCode = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.userId = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.email)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::value_size(2, self.errorCode, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.token);
        }
        if self.userId != 0 {
            my_size += ::protobuf::rt::value_size(4, self.userId, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.email);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.token.is_empty() {
            os.write_string(3, &self.token)?;
        }
        if self.userId != 0 {
            os.write_int32(4, self.userId)?;
        }
        if !self.email.is_empty() {
            os.write_string(5, &self.email)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLastLoginDataResponse {
        GetLastLoginDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &GetLastLoginDataResponse| { &m.success },
                |m: &mut GetLastLoginDataResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "errorCode",
                |m: &GetLastLoginDataResponse| { &m.errorCode },
                |m: &mut GetLastLoginDataResponse| { &mut m.errorCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &GetLastLoginDataResponse| { &m.token },
                |m: &mut GetLastLoginDataResponse| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "userId",
                |m: &GetLastLoginDataResponse| { &m.userId },
                |m: &mut GetLastLoginDataResponse| { &mut m.userId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email",
                |m: &GetLastLoginDataResponse| { &m.email },
                |m: &mut GetLastLoginDataResponse| { &mut m.email },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLastLoginDataResponse>(
                "GetLastLoginDataResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLastLoginDataResponse {
        static instance: ::protobuf::rt::LazyV2<GetLastLoginDataResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLastLoginDataResponse::new)
    }
}

impl ::protobuf::Clear for GetLastLoginDataResponse {
    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.token.clear();
        self.userId = 0;
        self.email.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLastLoginDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLastLoginDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchNotes {
    // message fields
    pub query: ::std::string::String,
    pub folderId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchNotes {
    fn default() -> &'a SearchNotes {
        <SearchNotes as ::protobuf::Message>::default_instance()
    }
}

impl SearchNotes {
    pub fn new() -> SearchNotes {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // string folderId = 2;


    pub fn get_folderId(&self) -> &str {
        &self.folderId
    }
    pub fn clear_folderId(&mut self) {
        self.folderId.clear();
    }

    // Param is passed by value, moved
    pub fn set_folderId(&mut self, v: ::std::string::String) {
        self.folderId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folderId(&mut self) -> &mut ::std::string::String {
        &mut self.folderId
    }

    // Take field
    pub fn take_folderId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.folderId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SearchNotes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.folderId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(2, &self.folderId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchNotes {
        SearchNotes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &SearchNotes| { &m.query },
                |m: &mut SearchNotes| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folderId",
                |m: &SearchNotes| { &m.folderId },
                |m: &mut SearchNotes| { &mut m.folderId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchNotes>(
                "SearchNotes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchNotes {
        static instance: ::protobuf::rt::LazyV2<SearchNotes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchNotes::new)
    }
}

impl ::protobuf::Clear for SearchNotes {
    fn clear(&mut self) {
        self.query.clear();
        self.folderId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchNotes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchNotes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateFolder {
    // message fields
    pub id: ::std::string::String,
    pub parentId: ::std::string::String,
    pub title: ::std::string::String,
    pub level: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateFolder {
    fn default() -> &'a UpdateFolder {
        <UpdateFolder as ::protobuf::Message>::default_instance()
    }
}

impl UpdateFolder {
    pub fn new() -> UpdateFolder {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string parentId = 2;


    pub fn get_parentId(&self) -> &str {
        &self.parentId
    }
    pub fn clear_parentId(&mut self) {
        self.parentId.clear();
    }

    // Param is passed by value, moved
    pub fn set_parentId(&mut self, v: ::std::string::String) {
        self.parentId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentId(&mut self) -> &mut ::std::string::String {
        &mut self.parentId
    }

    // Take field
    pub fn take_parentId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parentId, ::std::string::String::new())
    }

    // string title = 3;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // int32 level = 4;


    pub fn get_level(&self) -> i32 {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = 0;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: i32) {
        self.level = v;
    }
}

impl ::protobuf::Message for UpdateFolder {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parentId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.level = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.parentId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.parentId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.title);
        }
        if self.level != 0 {
            my_size += ::protobuf::rt::value_size(4, self.level, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.parentId.is_empty() {
            os.write_string(2, &self.parentId)?;
        }
        if !self.title.is_empty() {
            os.write_string(3, &self.title)?;
        }
        if self.level != 0 {
            os.write_int32(4, self.level)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateFolder {
        UpdateFolder::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &UpdateFolder| { &m.id },
                |m: &mut UpdateFolder| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parentId",
                |m: &UpdateFolder| { &m.parentId },
                |m: &mut UpdateFolder| { &mut m.parentId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &UpdateFolder| { &m.title },
                |m: &mut UpdateFolder| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "level",
                |m: &UpdateFolder| { &m.level },
                |m: &mut UpdateFolder| { &mut m.level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateFolder>(
                "UpdateFolder",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateFolder {
        static instance: ::protobuf::rt::LazyV2<UpdateFolder> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateFolder::new)
    }
}

impl ::protobuf::Clear for UpdateFolder {
    fn clear(&mut self) {
        self.id.clear();
        self.parentId.clear();
        self.title.clear();
        self.level = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateFolder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateFolder {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateNote {
    // message fields
    pub id: ::std::string::String,
    pub folderId: ::std::string::String,
    pub title: ::std::string::String,
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateNote {
    fn default() -> &'a UpdateNote {
        <UpdateNote as ::protobuf::Message>::default_instance()
    }
}

impl UpdateNote {
    pub fn new() -> UpdateNote {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string folderId = 2;


    pub fn get_folderId(&self) -> &str {
        &self.folderId
    }
    pub fn clear_folderId(&mut self) {
        self.folderId.clear();
    }

    // Param is passed by value, moved
    pub fn set_folderId(&mut self, v: ::std::string::String) {
        self.folderId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folderId(&mut self) -> &mut ::std::string::String {
        &mut self.folderId
    }

    // Take field
    pub fn take_folderId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.folderId, ::std::string::String::new())
    }

    // string title = 3;


    pub fn get_title(&self) -> &str {
        &self.title
    }
    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    // string text = 4;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateNote {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.folderId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.folderId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.title);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(2, &self.folderId)?;
        }
        if !self.title.is_empty() {
            os.write_string(3, &self.title)?;
        }
        if !self.text.is_empty() {
            os.write_string(4, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateNote {
        UpdateNote::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &UpdateNote| { &m.id },
                |m: &mut UpdateNote| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "folderId",
                |m: &UpdateNote| { &m.folderId },
                |m: &mut UpdateNote| { &mut m.folderId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "title",
                |m: &UpdateNote| { &m.title },
                |m: &mut UpdateNote| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &UpdateNote| { &m.text },
                |m: &mut UpdateNote| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateNote>(
                "UpdateNote",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateNote {
        static instance: ::protobuf::rt::LazyV2<UpdateNote> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateNote::new)
    }
}

impl ::protobuf::Clear for UpdateNote {
    fn clear(&mut self) {
        self.id.clear();
        self.folderId.clear();
        self.title.clear();
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateNote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateNote {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15protos/messages.proto\x12\x0cgigamessages\"@\n\x08InitData\x12\x1a\
    \n\x08dataPath\x18\x01\x20\x01(\tR\x08dataPath\x12\x18\n\x07apiPath\x18\
    \x02\x20\x01(\tR\x07apiPath\"9\n\x05Login\x12\x14\n\x05email\x18\x01\x20\
    \x01(\tR\x05email\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\x08password\
    \"u\n\rLoginResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07succe\
    ss\x12\x1c\n\terrorCode\x18\x02\x20\x01(\x05R\terrorCode\x12\x14\n\x05to\
    ken\x18\x03\x20\x01(\tR\x05token\x12\x16\n\x06userId\x18\x04\x20\x01(\
    \x05R\x06userId\"R\n\nCreateNote\x12\x14\n\x05title\x18\x01\x20\x01(\tR\
    \x05title\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\x12\x1a\n\x08fol\
    derId\x18\x03\x20\x01(\tR\x08folderId\"@\n\x0cCreateFolder\x12\x1a\n\x08\
    parentId\x18\x01\x20\x01(\tR\x08parentId\x12\x14\n\x05title\x18\x02\x20\
    \x01(\tR\x05title\"j\n\x14CreateFolderResponse\x12\x18\n\x07success\x18\
    \x01\x20\x01(\x08R\x07success\x12\x1c\n\terrorCode\x18\x02\x20\x01(\x05R\
    \terrorCode\x12\x1a\n\x08folderId\x18\x03\x20\x01(\tR\x08folderId\"d\n\
    \x12CreateNoteResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07suc\
    cess\x12\x1c\n\terrorCode\x18\x02\x20\x01(\x05R\terrorCode\x12\x16\n\x06\
    noteId\x18\x03\x20\x01(\tR\x06noteId\"*\n\x0cGetNotesList\x12\x1a\n\x08f\
    olderId\x18\x01\x20\x01(\tR\x08folderId\";\n\x0bGetAllNotes\x12\x16\n\
    \x06offset\x18\x01\x20\x01(\x05R\x06offset\x12\x14\n\x05limit\x18\x02\
    \x20\x01(\x05R\x05limit\"\x20\n\x08SetToken\x12\x14\n\x05token\x18\x01\
    \x20\x01(\tR\x05token\"\x8d\x01\n\rNoteShortInfo\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x1a\n\x08folderId\x18\x02\x20\x01(\tR\x08folderId\
    \x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\x12\x1c\n\tcreatedAt\
    \x18\x04\x20\x01(\x03R\tcreatedAt\x12\x1c\n\tupdatedAt\x18\x05\x20\x01(\
    \x03R\tupdatedAt\"\x81\x01\n\x14GetNotesListResponse\x12\x18\n\x07succes\
    s\x18\x01\x20\x01(\x08R\x07success\x12\x1c\n\terrorCode\x18\x02\x20\x01(\
    \x05R\terrorCode\x121\n\x05notes\x18\x03\x20\x03(\x0b2\x1b.gigamessages.\
    NoteShortInfoR\x05notes\"\x9c\x01\n\x06Folder\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\tR\x02id\x12\x1a\n\x08parentId\x18\x02\x20\x01(\tR\x08parentId\
    \x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\x12\x14\n\x05level\x18\
    \x04\x20\x01(\x05R\x05level\x12\x1c\n\tcreatedAt\x18\x05\x20\x01(\x03R\t\
    createdAt\x12\x1c\n\tupdatedAt\x18\x06\x20\x01(\x03R\tupdatedAt\"\x80\
    \x01\n\x16GetFoldersListResponse\x12\x18\n\x07success\x18\x01\x20\x01(\
    \x08R\x07success\x12\x1c\n\terrorCode\x18\x02\x20\x01(\x05R\terrorCode\
    \x12.\n\x07folders\x18\x03\x20\x03(\x0b2\x14.gigamessages.FolderR\x07fol\
    ders\"%\n\x0bGetNoteById\x12\x16\n\x06noteId\x18\x01\x20\x01(\tR\x06note\
    Id\"\xa3\x01\n\x13GetNoteByIdResponse\x12\x18\n\x07success\x18\x01\x20\
    \x01(\x08R\x07success\x12\x1c\n\terrorCode\x18\x02\x20\x01(\x05R\terrorC\
    ode\x12\x0e\n\x02id\x18\x03\x20\x01(\tR\x02id\x12\x1a\n\x08folderId\x18\
    \x04\x20\x01(\tR\x08folderId\x12\x14\n\x05title\x18\x05\x20\x01(\tR\x05t\
    itle\x12\x12\n\x04text\x18\x06\x20\x01(\tR\x04text\"+\n\rGetFolderById\
    \x12\x1a\n\x08folderId\x18\x01\x20\x01(\tR\x08folderId\"\xe3\x01\n\x15Ge\
    tFolderByIdResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07succes\
    s\x12\x1c\n\terrorCode\x18\x02\x20\x01(\x05R\terrorCode\x12\x0e\n\x02id\
    \x18\x03\x20\x01(\tR\x02id\x12\x14\n\x05title\x18\x04\x20\x01(\tR\x05tit\
    le\x12\x1a\n\x08parentId\x18\x05\x20\x01(\tR\x08parentId\x12\x14\n\x05le\
    vel\x18\x06\x20\x01(\x05R\x05level\x12\x1c\n\tcreatedAt\x18\x07\x20\x01(\
    \x03R\tcreatedAt\x12\x1c\n\tupdatedAt\x18\x08\x20\x01(\x03R\tupdatedAt\"\
    $\n\nRemoveNote\x12\x16\n\x06noteId\x18\x01\x20\x01(\tR\x06noteId\"*\n\
    \x0cRemoveFolder\x12\x1a\n\x08folderId\x18\x01\x20\x01(\tR\x08folderId\"\
    \x81\x01\n\x15GetRootFolderResponse\x12\x18\n\x07success\x18\x01\x20\x01\
    (\x08R\x07success\x12\x1c\n\terrorCode\x18\x02\x20\x01(\x05R\terrorCode\
    \x12\x1a\n\x08folderId\x18\x03\x20\x01(\tR\x08folderId\x12\x14\n\x05titl\
    e\x18\x05\x20\x01(\tR\x05title\"M\n\x13EmptyResultResponse\x12\x18\n\x07\
    success\x18\x01\x20\x01(\x08R\x07success\x12\x1c\n\terrorCode\x18\x02\
    \x20\x01(\x05R\terrorCode\"\x96\x01\n\x18GetLastLoginDataResponse\x12\
    \x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\x12\x1c\n\terrorCode\
    \x18\x02\x20\x01(\x05R\terrorCode\x12\x14\n\x05token\x18\x03\x20\x01(\tR\
    \x05token\x12\x16\n\x06userId\x18\x04\x20\x01(\x05R\x06userId\x12\x14\n\
    \x05email\x18\x05\x20\x01(\tR\x05email\"?\n\x0bSearchNotes\x12\x14\n\x05\
    query\x18\x01\x20\x01(\tR\x05query\x12\x1a\n\x08folderId\x18\x02\x20\x01\
    (\tR\x08folderId\"f\n\x0cUpdateFolder\x12\x0e\n\x02id\x18\x01\x20\x01(\t\
    R\x02id\x12\x1a\n\x08parentId\x18\x02\x20\x01(\tR\x08parentId\x12\x14\n\
    \x05title\x18\x03\x20\x01(\tR\x05title\x12\x14\n\x05level\x18\x04\x20\
    \x01(\x05R\x05level\"b\n\nUpdateNote\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12\x1a\n\x08folderId\x18\x02\x20\x01(\tR\x08folderId\x12\x14\n\
    \x05title\x18\x03\x20\x01(\tR\x05title\x12\x12\n\x04text\x18\x04\x20\x01\
    (\tR\x04textb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
