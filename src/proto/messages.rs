// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `protos/messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.InitData)
pub struct InitData {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.InitData.dataPath)
    pub dataPath: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.InitData.apiPath)
    pub apiPath: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.InitData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InitData {
    fn default() -> &'a InitData {
        <InitData as ::protobuf::Message>::default_instance()
    }
}

impl InitData {
    pub fn new() -> InitData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataPath",
            |m: &InitData| { &m.dataPath },
            |m: &mut InitData| { &mut m.dataPath },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "apiPath",
            |m: &InitData| { &m.apiPath },
            |m: &mut InitData| { &mut m.apiPath },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InitData>(
            "InitData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InitData {
    const NAME: &'static str = "InitData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dataPath = is.read_string()?;
                },
                18 => {
                    self.apiPath = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.dataPath.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataPath);
        }
        if !self.apiPath.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.apiPath);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.dataPath.is_empty() {
            os.write_string(1, &self.dataPath)?;
        }
        if !self.apiPath.is_empty() {
            os.write_string(2, &self.apiPath)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InitData {
        InitData::new()
    }

    fn clear(&mut self) {
        self.dataPath.clear();
        self.apiPath.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InitData {
        static instance: InitData = InitData {
            dataPath: ::std::string::String::new(),
            apiPath: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InitData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InitData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InitData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InitData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.Login)
pub struct Login {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.Login.email)
    pub email: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.Login.password)
    pub password: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.Login.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Login {
    fn default() -> &'a Login {
        <Login as ::protobuf::Message>::default_instance()
    }
}

impl Login {
    pub fn new() -> Login {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "email",
            |m: &Login| { &m.email },
            |m: &mut Login| { &mut m.email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &Login| { &m.password },
            |m: &mut Login| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Login>(
            "Login",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Login {
    const NAME: &'static str = "Login";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.email = is.read_string()?;
                },
                18 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.email);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.email.is_empty() {
            os.write_string(1, &self.email)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Login {
        Login::new()
    }

    fn clear(&mut self) {
        self.email.clear();
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Login {
        static instance: Login = Login {
            email: ::std::string::String::new(),
            password: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Login {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Login").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Login {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Login {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.LoginSocial)
pub struct LoginSocial {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.LoginSocial.email)
    pub email: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.LoginSocial.provider)
    pub provider: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.LoginSocial.token)
    pub token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.LoginSocial.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginSocial {
    fn default() -> &'a LoginSocial {
        <LoginSocial as ::protobuf::Message>::default_instance()
    }
}

impl LoginSocial {
    pub fn new() -> LoginSocial {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "email",
            |m: &LoginSocial| { &m.email },
            |m: &mut LoginSocial| { &mut m.email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "provider",
            |m: &LoginSocial| { &m.provider },
            |m: &mut LoginSocial| { &mut m.provider },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token",
            |m: &LoginSocial| { &m.token },
            |m: &mut LoginSocial| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginSocial>(
            "LoginSocial",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginSocial {
    const NAME: &'static str = "LoginSocial";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.email = is.read_string()?;
                },
                18 => {
                    self.provider = is.read_string()?;
                },
                26 => {
                    self.token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.email);
        }
        if !self.provider.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.provider);
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.email.is_empty() {
            os.write_string(1, &self.email)?;
        }
        if !self.provider.is_empty() {
            os.write_string(2, &self.provider)?;
        }
        if !self.token.is_empty() {
            os.write_string(3, &self.token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginSocial {
        LoginSocial::new()
    }

    fn clear(&mut self) {
        self.email.clear();
        self.provider.clear();
        self.token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginSocial {
        static instance: LoginSocial = LoginSocial {
            email: ::std::string::String::new(),
            provider: ::std::string::String::new(),
            token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginSocial {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginSocial").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginSocial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginSocial {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.LoginResponse)
pub struct LoginResponse {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.LoginResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:gigamessages.LoginResponse.errorCode)
    pub errorCode: i32,
    // @@protoc_insertion_point(field:gigamessages.LoginResponse.token)
    pub token: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.LoginResponse.userId)
    pub userId: i32,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.LoginResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginResponse {
    fn default() -> &'a LoginResponse {
        <LoginResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoginResponse {
    pub fn new() -> LoginResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &LoginResponse| { &m.success },
            |m: &mut LoginResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorCode",
            |m: &LoginResponse| { &m.errorCode },
            |m: &mut LoginResponse| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token",
            |m: &LoginResponse| { &m.token },
            |m: &mut LoginResponse| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &LoginResponse| { &m.userId },
            |m: &mut LoginResponse| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginResponse>(
            "LoginResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginResponse {
    const NAME: &'static str = "LoginResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.errorCode = is.read_int32()?;
                },
                26 => {
                    self.token = is.read_string()?;
                },
                32 => {
                    self.userId = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.errorCode);
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.token);
        }
        if self.userId != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.userId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.token.is_empty() {
            os.write_string(3, &self.token)?;
        }
        if self.userId != 0 {
            os.write_int32(4, self.userId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginResponse {
        LoginResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.token.clear();
        self.userId = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginResponse {
        static instance: LoginResponse = LoginResponse {
            success: false,
            errorCode: 0,
            token: ::std::string::String::new(),
            userId: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.CreateNote)
pub struct CreateNote {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.CreateNote.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.CreateNote.text)
    pub text: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.CreateNote.folderId)
    pub folderId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.CreateNote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateNote {
    fn default() -> &'a CreateNote {
        <CreateNote as ::protobuf::Message>::default_instance()
    }
}

impl CreateNote {
    pub fn new() -> CreateNote {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &CreateNote| { &m.title },
            |m: &mut CreateNote| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &CreateNote| { &m.text },
            |m: &mut CreateNote| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "folderId",
            |m: &CreateNote| { &m.folderId },
            |m: &mut CreateNote| { &mut m.folderId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateNote>(
            "CreateNote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateNote {
    const NAME: &'static str = "CreateNote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = is.read_string()?;
                },
                18 => {
                    self.text = is.read_string()?;
                },
                26 => {
                    self.folderId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.text);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.text.is_empty() {
            os.write_string(2, &self.text)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(3, &self.folderId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateNote {
        CreateNote::new()
    }

    fn clear(&mut self) {
        self.title.clear();
        self.text.clear();
        self.folderId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateNote {
        static instance: CreateNote = CreateNote {
            title: ::std::string::String::new(),
            text: ::std::string::String::new(),
            folderId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateNote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateNote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateNote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateNote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.CreateFolder)
pub struct CreateFolder {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.CreateFolder.parentId)
    pub parentId: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.CreateFolder.title)
    pub title: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.CreateFolder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateFolder {
    fn default() -> &'a CreateFolder {
        <CreateFolder as ::protobuf::Message>::default_instance()
    }
}

impl CreateFolder {
    pub fn new() -> CreateFolder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parentId",
            |m: &CreateFolder| { &m.parentId },
            |m: &mut CreateFolder| { &mut m.parentId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &CreateFolder| { &m.title },
            |m: &mut CreateFolder| { &mut m.title },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateFolder>(
            "CreateFolder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateFolder {
    const NAME: &'static str = "CreateFolder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.parentId = is.read_string()?;
                },
                18 => {
                    self.title = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.parentId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parentId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.title);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.parentId.is_empty() {
            os.write_string(1, &self.parentId)?;
        }
        if !self.title.is_empty() {
            os.write_string(2, &self.title)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateFolder {
        CreateFolder::new()
    }

    fn clear(&mut self) {
        self.parentId.clear();
        self.title.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateFolder {
        static instance: CreateFolder = CreateFolder {
            parentId: ::std::string::String::new(),
            title: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateFolder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateFolder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateFolder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFolder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.CreateFolderResponse)
pub struct CreateFolderResponse {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.CreateFolderResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:gigamessages.CreateFolderResponse.errorCode)
    pub errorCode: i32,
    // @@protoc_insertion_point(field:gigamessages.CreateFolderResponse.folderId)
    pub folderId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.CreateFolderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateFolderResponse {
    fn default() -> &'a CreateFolderResponse {
        <CreateFolderResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateFolderResponse {
    pub fn new() -> CreateFolderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &CreateFolderResponse| { &m.success },
            |m: &mut CreateFolderResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorCode",
            |m: &CreateFolderResponse| { &m.errorCode },
            |m: &mut CreateFolderResponse| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "folderId",
            |m: &CreateFolderResponse| { &m.folderId },
            |m: &mut CreateFolderResponse| { &mut m.folderId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateFolderResponse>(
            "CreateFolderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateFolderResponse {
    const NAME: &'static str = "CreateFolderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.errorCode = is.read_int32()?;
                },
                26 => {
                    self.folderId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.errorCode);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(3, &self.folderId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateFolderResponse {
        CreateFolderResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.folderId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateFolderResponse {
        static instance: CreateFolderResponse = CreateFolderResponse {
            success: false,
            errorCode: 0,
            folderId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateFolderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateFolderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateFolderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFolderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.CreateNoteResponse)
pub struct CreateNoteResponse {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.CreateNoteResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:gigamessages.CreateNoteResponse.errorCode)
    pub errorCode: i32,
    // @@protoc_insertion_point(field:gigamessages.CreateNoteResponse.noteId)
    pub noteId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.CreateNoteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateNoteResponse {
    fn default() -> &'a CreateNoteResponse {
        <CreateNoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateNoteResponse {
    pub fn new() -> CreateNoteResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &CreateNoteResponse| { &m.success },
            |m: &mut CreateNoteResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorCode",
            |m: &CreateNoteResponse| { &m.errorCode },
            |m: &mut CreateNoteResponse| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "noteId",
            |m: &CreateNoteResponse| { &m.noteId },
            |m: &mut CreateNoteResponse| { &mut m.noteId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateNoteResponse>(
            "CreateNoteResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateNoteResponse {
    const NAME: &'static str = "CreateNoteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.errorCode = is.read_int32()?;
                },
                26 => {
                    self.noteId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.errorCode);
        }
        if !self.noteId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.noteId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.noteId.is_empty() {
            os.write_string(3, &self.noteId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateNoteResponse {
        CreateNoteResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.noteId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateNoteResponse {
        static instance: CreateNoteResponse = CreateNoteResponse {
            success: false,
            errorCode: 0,
            noteId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateNoteResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateNoteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateNoteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateNoteResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.GetNotesList)
pub struct GetNotesList {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.GetNotesList.folderId)
    pub folderId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.GetNotesList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetNotesList {
    fn default() -> &'a GetNotesList {
        <GetNotesList as ::protobuf::Message>::default_instance()
    }
}

impl GetNotesList {
    pub fn new() -> GetNotesList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "folderId",
            |m: &GetNotesList| { &m.folderId },
            |m: &mut GetNotesList| { &mut m.folderId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetNotesList>(
            "GetNotesList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetNotesList {
    const NAME: &'static str = "GetNotesList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.folderId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.folderId.is_empty() {
            os.write_string(1, &self.folderId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetNotesList {
        GetNotesList::new()
    }

    fn clear(&mut self) {
        self.folderId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetNotesList {
        static instance: GetNotesList = GetNotesList {
            folderId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetNotesList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetNotesList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetNotesList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNotesList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.GetAllNotes)
pub struct GetAllNotes {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.GetAllNotes.offset)
    pub offset: i32,
    // @@protoc_insertion_point(field:gigamessages.GetAllNotes.limit)
    pub limit: i32,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.GetAllNotes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAllNotes {
    fn default() -> &'a GetAllNotes {
        <GetAllNotes as ::protobuf::Message>::default_instance()
    }
}

impl GetAllNotes {
    pub fn new() -> GetAllNotes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &GetAllNotes| { &m.offset },
            |m: &mut GetAllNotes| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &GetAllNotes| { &m.limit },
            |m: &mut GetAllNotes| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllNotes>(
            "GetAllNotes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAllNotes {
    const NAME: &'static str = "GetAllNotes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.offset = is.read_int32()?;
                },
                16 => {
                    self.limit = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.offset != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.offset);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.offset != 0 {
            os.write_int32(1, self.offset)?;
        }
        if self.limit != 0 {
            os.write_int32(2, self.limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAllNotes {
        GetAllNotes::new()
    }

    fn clear(&mut self) {
        self.offset = 0;
        self.limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAllNotes {
        static instance: GetAllNotes = GetAllNotes {
            offset: 0,
            limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAllNotes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAllNotes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAllNotes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllNotes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.SetToken)
pub struct SetToken {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.SetToken.token)
    pub token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.SetToken.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetToken {
    fn default() -> &'a SetToken {
        <SetToken as ::protobuf::Message>::default_instance()
    }
}

impl SetToken {
    pub fn new() -> SetToken {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token",
            |m: &SetToken| { &m.token },
            |m: &mut SetToken| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetToken>(
            "SetToken",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetToken {
    const NAME: &'static str = "SetToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.token.is_empty() {
            os.write_string(1, &self.token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetToken {
        SetToken::new()
    }

    fn clear(&mut self) {
        self.token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetToken {
        static instance: SetToken = SetToken {
            token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetToken {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetToken").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetToken {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.NoteShortInfo)
pub struct NoteShortInfo {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.NoteShortInfo.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.NoteShortInfo.folderId)
    pub folderId: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.NoteShortInfo.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.NoteShortInfo.createdAt)
    pub createdAt: i64,
    // @@protoc_insertion_point(field:gigamessages.NoteShortInfo.updatedAt)
    pub updatedAt: i64,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.NoteShortInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NoteShortInfo {
    fn default() -> &'a NoteShortInfo {
        <NoteShortInfo as ::protobuf::Message>::default_instance()
    }
}

impl NoteShortInfo {
    pub fn new() -> NoteShortInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &NoteShortInfo| { &m.id },
            |m: &mut NoteShortInfo| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "folderId",
            |m: &NoteShortInfo| { &m.folderId },
            |m: &mut NoteShortInfo| { &mut m.folderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &NoteShortInfo| { &m.title },
            |m: &mut NoteShortInfo| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "createdAt",
            |m: &NoteShortInfo| { &m.createdAt },
            |m: &mut NoteShortInfo| { &mut m.createdAt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updatedAt",
            |m: &NoteShortInfo| { &m.updatedAt },
            |m: &mut NoteShortInfo| { &mut m.updatedAt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoteShortInfo>(
            "NoteShortInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NoteShortInfo {
    const NAME: &'static str = "NoteShortInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.folderId = is.read_string()?;
                },
                26 => {
                    self.title = is.read_string()?;
                },
                32 => {
                    self.createdAt = is.read_int64()?;
                },
                40 => {
                    self.updatedAt = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.folderId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.title);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.createdAt);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.updatedAt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(2, &self.folderId)?;
        }
        if !self.title.is_empty() {
            os.write_string(3, &self.title)?;
        }
        if self.createdAt != 0 {
            os.write_int64(4, self.createdAt)?;
        }
        if self.updatedAt != 0 {
            os.write_int64(5, self.updatedAt)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NoteShortInfo {
        NoteShortInfo::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.folderId.clear();
        self.title.clear();
        self.createdAt = 0;
        self.updatedAt = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NoteShortInfo {
        static instance: NoteShortInfo = NoteShortInfo {
            id: ::std::string::String::new(),
            folderId: ::std::string::String::new(),
            title: ::std::string::String::new(),
            createdAt: 0,
            updatedAt: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NoteShortInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NoteShortInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NoteShortInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoteShortInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.GetNotesListResponse)
pub struct GetNotesListResponse {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.GetNotesListResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:gigamessages.GetNotesListResponse.errorCode)
    pub errorCode: i32,
    // @@protoc_insertion_point(field:gigamessages.GetNotesListResponse.notes)
    pub notes: ::std::vec::Vec<NoteShortInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.GetNotesListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetNotesListResponse {
    fn default() -> &'a GetNotesListResponse {
        <GetNotesListResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetNotesListResponse {
    pub fn new() -> GetNotesListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &GetNotesListResponse| { &m.success },
            |m: &mut GetNotesListResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorCode",
            |m: &GetNotesListResponse| { &m.errorCode },
            |m: &mut GetNotesListResponse| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notes",
            |m: &GetNotesListResponse| { &m.notes },
            |m: &mut GetNotesListResponse| { &mut m.notes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetNotesListResponse>(
            "GetNotesListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetNotesListResponse {
    const NAME: &'static str = "GetNotesListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.errorCode = is.read_int32()?;
                },
                26 => {
                    self.notes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.errorCode);
        }
        for value in &self.notes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        for v in &self.notes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetNotesListResponse {
        GetNotesListResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.notes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetNotesListResponse {
        static instance: GetNotesListResponse = GetNotesListResponse {
            success: false,
            errorCode: 0,
            notes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetNotesListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetNotesListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetNotesListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNotesListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.Folder)
pub struct Folder {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.Folder.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.Folder.parentId)
    pub parentId: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.Folder.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.Folder.level)
    pub level: i32,
    // @@protoc_insertion_point(field:gigamessages.Folder.createdAt)
    pub createdAt: i64,
    // @@protoc_insertion_point(field:gigamessages.Folder.updatedAt)
    pub updatedAt: i64,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.Folder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Folder {
    fn default() -> &'a Folder {
        <Folder as ::protobuf::Message>::default_instance()
    }
}

impl Folder {
    pub fn new() -> Folder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Folder| { &m.id },
            |m: &mut Folder| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parentId",
            |m: &Folder| { &m.parentId },
            |m: &mut Folder| { &mut m.parentId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &Folder| { &m.title },
            |m: &mut Folder| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &Folder| { &m.level },
            |m: &mut Folder| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "createdAt",
            |m: &Folder| { &m.createdAt },
            |m: &mut Folder| { &mut m.createdAt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updatedAt",
            |m: &Folder| { &m.updatedAt },
            |m: &mut Folder| { &mut m.updatedAt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Folder>(
            "Folder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Folder {
    const NAME: &'static str = "Folder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.parentId = is.read_string()?;
                },
                26 => {
                    self.title = is.read_string()?;
                },
                32 => {
                    self.level = is.read_int32()?;
                },
                40 => {
                    self.createdAt = is.read_int64()?;
                },
                48 => {
                    self.updatedAt = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.parentId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.parentId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.title);
        }
        if self.level != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.level);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.createdAt);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.updatedAt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.parentId.is_empty() {
            os.write_string(2, &self.parentId)?;
        }
        if !self.title.is_empty() {
            os.write_string(3, &self.title)?;
        }
        if self.level != 0 {
            os.write_int32(4, self.level)?;
        }
        if self.createdAt != 0 {
            os.write_int64(5, self.createdAt)?;
        }
        if self.updatedAt != 0 {
            os.write_int64(6, self.updatedAt)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Folder {
        Folder::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.parentId.clear();
        self.title.clear();
        self.level = 0;
        self.createdAt = 0;
        self.updatedAt = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Folder {
        static instance: Folder = Folder {
            id: ::std::string::String::new(),
            parentId: ::std::string::String::new(),
            title: ::std::string::String::new(),
            level: 0,
            createdAt: 0,
            updatedAt: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Folder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Folder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Folder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Folder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.GetFoldersListResponse)
pub struct GetFoldersListResponse {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.GetFoldersListResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:gigamessages.GetFoldersListResponse.errorCode)
    pub errorCode: i32,
    // @@protoc_insertion_point(field:gigamessages.GetFoldersListResponse.folders)
    pub folders: ::std::vec::Vec<Folder>,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.GetFoldersListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFoldersListResponse {
    fn default() -> &'a GetFoldersListResponse {
        <GetFoldersListResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFoldersListResponse {
    pub fn new() -> GetFoldersListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &GetFoldersListResponse| { &m.success },
            |m: &mut GetFoldersListResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorCode",
            |m: &GetFoldersListResponse| { &m.errorCode },
            |m: &mut GetFoldersListResponse| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "folders",
            |m: &GetFoldersListResponse| { &m.folders },
            |m: &mut GetFoldersListResponse| { &mut m.folders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFoldersListResponse>(
            "GetFoldersListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFoldersListResponse {
    const NAME: &'static str = "GetFoldersListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.errorCode = is.read_int32()?;
                },
                26 => {
                    self.folders.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.errorCode);
        }
        for value in &self.folders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        for v in &self.folders {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFoldersListResponse {
        GetFoldersListResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.folders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFoldersListResponse {
        static instance: GetFoldersListResponse = GetFoldersListResponse {
            success: false,
            errorCode: 0,
            folders: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFoldersListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFoldersListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFoldersListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFoldersListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.GetNoteById)
pub struct GetNoteById {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.GetNoteById.noteId)
    pub noteId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.GetNoteById.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetNoteById {
    fn default() -> &'a GetNoteById {
        <GetNoteById as ::protobuf::Message>::default_instance()
    }
}

impl GetNoteById {
    pub fn new() -> GetNoteById {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "noteId",
            |m: &GetNoteById| { &m.noteId },
            |m: &mut GetNoteById| { &mut m.noteId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetNoteById>(
            "GetNoteById",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetNoteById {
    const NAME: &'static str = "GetNoteById";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.noteId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.noteId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.noteId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.noteId.is_empty() {
            os.write_string(1, &self.noteId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetNoteById {
        GetNoteById::new()
    }

    fn clear(&mut self) {
        self.noteId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetNoteById {
        static instance: GetNoteById = GetNoteById {
            noteId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetNoteById {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetNoteById").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetNoteById {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNoteById {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.GetNoteByIdResponse)
pub struct GetNoteByIdResponse {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.GetNoteByIdResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:gigamessages.GetNoteByIdResponse.errorCode)
    pub errorCode: i32,
    // @@protoc_insertion_point(field:gigamessages.GetNoteByIdResponse.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.GetNoteByIdResponse.folderId)
    pub folderId: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.GetNoteByIdResponse.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.GetNoteByIdResponse.text)
    pub text: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.GetNoteByIdResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetNoteByIdResponse {
    fn default() -> &'a GetNoteByIdResponse {
        <GetNoteByIdResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetNoteByIdResponse {
    pub fn new() -> GetNoteByIdResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &GetNoteByIdResponse| { &m.success },
            |m: &mut GetNoteByIdResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorCode",
            |m: &GetNoteByIdResponse| { &m.errorCode },
            |m: &mut GetNoteByIdResponse| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetNoteByIdResponse| { &m.id },
            |m: &mut GetNoteByIdResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "folderId",
            |m: &GetNoteByIdResponse| { &m.folderId },
            |m: &mut GetNoteByIdResponse| { &mut m.folderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &GetNoteByIdResponse| { &m.title },
            |m: &mut GetNoteByIdResponse| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &GetNoteByIdResponse| { &m.text },
            |m: &mut GetNoteByIdResponse| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetNoteByIdResponse>(
            "GetNoteByIdResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetNoteByIdResponse {
    const NAME: &'static str = "GetNoteByIdResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.errorCode = is.read_int32()?;
                },
                26 => {
                    self.id = is.read_string()?;
                },
                34 => {
                    self.folderId = is.read_string()?;
                },
                42 => {
                    self.title = is.read_string()?;
                },
                50 => {
                    self.text = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.errorCode);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.folderId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.title);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(4, &self.folderId)?;
        }
        if !self.title.is_empty() {
            os.write_string(5, &self.title)?;
        }
        if !self.text.is_empty() {
            os.write_string(6, &self.text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetNoteByIdResponse {
        GetNoteByIdResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.id.clear();
        self.folderId.clear();
        self.title.clear();
        self.text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetNoteByIdResponse {
        static instance: GetNoteByIdResponse = GetNoteByIdResponse {
            success: false,
            errorCode: 0,
            id: ::std::string::String::new(),
            folderId: ::std::string::String::new(),
            title: ::std::string::String::new(),
            text: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetNoteByIdResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetNoteByIdResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetNoteByIdResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNoteByIdResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.GetFolderById)
pub struct GetFolderById {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.GetFolderById.folderId)
    pub folderId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.GetFolderById.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFolderById {
    fn default() -> &'a GetFolderById {
        <GetFolderById as ::protobuf::Message>::default_instance()
    }
}

impl GetFolderById {
    pub fn new() -> GetFolderById {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "folderId",
            |m: &GetFolderById| { &m.folderId },
            |m: &mut GetFolderById| { &mut m.folderId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFolderById>(
            "GetFolderById",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFolderById {
    const NAME: &'static str = "GetFolderById";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.folderId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.folderId.is_empty() {
            os.write_string(1, &self.folderId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFolderById {
        GetFolderById::new()
    }

    fn clear(&mut self) {
        self.folderId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFolderById {
        static instance: GetFolderById = GetFolderById {
            folderId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFolderById {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFolderById").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFolderById {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFolderById {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.GetFolderByIdResponse)
pub struct GetFolderByIdResponse {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.GetFolderByIdResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:gigamessages.GetFolderByIdResponse.errorCode)
    pub errorCode: i32,
    // @@protoc_insertion_point(field:gigamessages.GetFolderByIdResponse.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.GetFolderByIdResponse.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.GetFolderByIdResponse.parentId)
    pub parentId: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.GetFolderByIdResponse.level)
    pub level: i32,
    // @@protoc_insertion_point(field:gigamessages.GetFolderByIdResponse.createdAt)
    pub createdAt: i64,
    // @@protoc_insertion_point(field:gigamessages.GetFolderByIdResponse.updatedAt)
    pub updatedAt: i64,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.GetFolderByIdResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFolderByIdResponse {
    fn default() -> &'a GetFolderByIdResponse {
        <GetFolderByIdResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFolderByIdResponse {
    pub fn new() -> GetFolderByIdResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &GetFolderByIdResponse| { &m.success },
            |m: &mut GetFolderByIdResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorCode",
            |m: &GetFolderByIdResponse| { &m.errorCode },
            |m: &mut GetFolderByIdResponse| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &GetFolderByIdResponse| { &m.id },
            |m: &mut GetFolderByIdResponse| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &GetFolderByIdResponse| { &m.title },
            |m: &mut GetFolderByIdResponse| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parentId",
            |m: &GetFolderByIdResponse| { &m.parentId },
            |m: &mut GetFolderByIdResponse| { &mut m.parentId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &GetFolderByIdResponse| { &m.level },
            |m: &mut GetFolderByIdResponse| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "createdAt",
            |m: &GetFolderByIdResponse| { &m.createdAt },
            |m: &mut GetFolderByIdResponse| { &mut m.createdAt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updatedAt",
            |m: &GetFolderByIdResponse| { &m.updatedAt },
            |m: &mut GetFolderByIdResponse| { &mut m.updatedAt },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFolderByIdResponse>(
            "GetFolderByIdResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFolderByIdResponse {
    const NAME: &'static str = "GetFolderByIdResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.errorCode = is.read_int32()?;
                },
                26 => {
                    self.id = is.read_string()?;
                },
                34 => {
                    self.title = is.read_string()?;
                },
                42 => {
                    self.parentId = is.read_string()?;
                },
                48 => {
                    self.level = is.read_int32()?;
                },
                56 => {
                    self.createdAt = is.read_int64()?;
                },
                64 => {
                    self.updatedAt = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.errorCode);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.id);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.title);
        }
        if !self.parentId.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.parentId);
        }
        if self.level != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.level);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.createdAt);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.updatedAt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.id.is_empty() {
            os.write_string(3, &self.id)?;
        }
        if !self.title.is_empty() {
            os.write_string(4, &self.title)?;
        }
        if !self.parentId.is_empty() {
            os.write_string(5, &self.parentId)?;
        }
        if self.level != 0 {
            os.write_int32(6, self.level)?;
        }
        if self.createdAt != 0 {
            os.write_int64(7, self.createdAt)?;
        }
        if self.updatedAt != 0 {
            os.write_int64(8, self.updatedAt)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFolderByIdResponse {
        GetFolderByIdResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.id.clear();
        self.title.clear();
        self.parentId.clear();
        self.level = 0;
        self.createdAt = 0;
        self.updatedAt = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFolderByIdResponse {
        static instance: GetFolderByIdResponse = GetFolderByIdResponse {
            success: false,
            errorCode: 0,
            id: ::std::string::String::new(),
            title: ::std::string::String::new(),
            parentId: ::std::string::String::new(),
            level: 0,
            createdAt: 0,
            updatedAt: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFolderByIdResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFolderByIdResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFolderByIdResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFolderByIdResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.RemoveNote)
pub struct RemoveNote {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.RemoveNote.noteId)
    pub noteId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.RemoveNote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveNote {
    fn default() -> &'a RemoveNote {
        <RemoveNote as ::protobuf::Message>::default_instance()
    }
}

impl RemoveNote {
    pub fn new() -> RemoveNote {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "noteId",
            |m: &RemoveNote| { &m.noteId },
            |m: &mut RemoveNote| { &mut m.noteId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveNote>(
            "RemoveNote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveNote {
    const NAME: &'static str = "RemoveNote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.noteId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.noteId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.noteId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.noteId.is_empty() {
            os.write_string(1, &self.noteId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveNote {
        RemoveNote::new()
    }

    fn clear(&mut self) {
        self.noteId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveNote {
        static instance: RemoveNote = RemoveNote {
            noteId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveNote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveNote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveNote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveNote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.RemoveFolder)
pub struct RemoveFolder {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.RemoveFolder.folderId)
    pub folderId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.RemoveFolder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveFolder {
    fn default() -> &'a RemoveFolder {
        <RemoveFolder as ::protobuf::Message>::default_instance()
    }
}

impl RemoveFolder {
    pub fn new() -> RemoveFolder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "folderId",
            |m: &RemoveFolder| { &m.folderId },
            |m: &mut RemoveFolder| { &mut m.folderId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveFolder>(
            "RemoveFolder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveFolder {
    const NAME: &'static str = "RemoveFolder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.folderId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.folderId.is_empty() {
            os.write_string(1, &self.folderId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveFolder {
        RemoveFolder::new()
    }

    fn clear(&mut self) {
        self.folderId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveFolder {
        static instance: RemoveFolder = RemoveFolder {
            folderId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveFolder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveFolder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveFolder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveFolder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.GetRootFolderResponse)
pub struct GetRootFolderResponse {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.GetRootFolderResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:gigamessages.GetRootFolderResponse.errorCode)
    pub errorCode: i32,
    // @@protoc_insertion_point(field:gigamessages.GetRootFolderResponse.folderId)
    pub folderId: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.GetRootFolderResponse.title)
    pub title: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.GetRootFolderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetRootFolderResponse {
    fn default() -> &'a GetRootFolderResponse {
        <GetRootFolderResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetRootFolderResponse {
    pub fn new() -> GetRootFolderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &GetRootFolderResponse| { &m.success },
            |m: &mut GetRootFolderResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorCode",
            |m: &GetRootFolderResponse| { &m.errorCode },
            |m: &mut GetRootFolderResponse| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "folderId",
            |m: &GetRootFolderResponse| { &m.folderId },
            |m: &mut GetRootFolderResponse| { &mut m.folderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &GetRootFolderResponse| { &m.title },
            |m: &mut GetRootFolderResponse| { &mut m.title },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetRootFolderResponse>(
            "GetRootFolderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetRootFolderResponse {
    const NAME: &'static str = "GetRootFolderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.errorCode = is.read_int32()?;
                },
                26 => {
                    self.folderId = is.read_string()?;
                },
                42 => {
                    self.title = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.errorCode);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.folderId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.title);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(3, &self.folderId)?;
        }
        if !self.title.is_empty() {
            os.write_string(5, &self.title)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetRootFolderResponse {
        GetRootFolderResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.folderId.clear();
        self.title.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetRootFolderResponse {
        static instance: GetRootFolderResponse = GetRootFolderResponse {
            success: false,
            errorCode: 0,
            folderId: ::std::string::String::new(),
            title: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetRootFolderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetRootFolderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetRootFolderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRootFolderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.EmptyResultResponse)
pub struct EmptyResultResponse {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.EmptyResultResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:gigamessages.EmptyResultResponse.errorCode)
    pub errorCode: i32,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.EmptyResultResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EmptyResultResponse {
    fn default() -> &'a EmptyResultResponse {
        <EmptyResultResponse as ::protobuf::Message>::default_instance()
    }
}

impl EmptyResultResponse {
    pub fn new() -> EmptyResultResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &EmptyResultResponse| { &m.success },
            |m: &mut EmptyResultResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorCode",
            |m: &EmptyResultResponse| { &m.errorCode },
            |m: &mut EmptyResultResponse| { &mut m.errorCode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EmptyResultResponse>(
            "EmptyResultResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EmptyResultResponse {
    const NAME: &'static str = "EmptyResultResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.errorCode = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.errorCode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EmptyResultResponse {
        EmptyResultResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EmptyResultResponse {
        static instance: EmptyResultResponse = EmptyResultResponse {
            success: false,
            errorCode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EmptyResultResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EmptyResultResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EmptyResultResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmptyResultResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.GetLastLoginDataResponse)
pub struct GetLastLoginDataResponse {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.GetLastLoginDataResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:gigamessages.GetLastLoginDataResponse.errorCode)
    pub errorCode: i32,
    // @@protoc_insertion_point(field:gigamessages.GetLastLoginDataResponse.token)
    pub token: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.GetLastLoginDataResponse.userId)
    pub userId: i32,
    // @@protoc_insertion_point(field:gigamessages.GetLastLoginDataResponse.email)
    pub email: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.GetLastLoginDataResponse.isTokenValid)
    pub isTokenValid: bool,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.GetLastLoginDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLastLoginDataResponse {
    fn default() -> &'a GetLastLoginDataResponse {
        <GetLastLoginDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLastLoginDataResponse {
    pub fn new() -> GetLastLoginDataResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &GetLastLoginDataResponse| { &m.success },
            |m: &mut GetLastLoginDataResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "errorCode",
            |m: &GetLastLoginDataResponse| { &m.errorCode },
            |m: &mut GetLastLoginDataResponse| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token",
            |m: &GetLastLoginDataResponse| { &m.token },
            |m: &mut GetLastLoginDataResponse| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &GetLastLoginDataResponse| { &m.userId },
            |m: &mut GetLastLoginDataResponse| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "email",
            |m: &GetLastLoginDataResponse| { &m.email },
            |m: &mut GetLastLoginDataResponse| { &mut m.email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isTokenValid",
            |m: &GetLastLoginDataResponse| { &m.isTokenValid },
            |m: &mut GetLastLoginDataResponse| { &mut m.isTokenValid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLastLoginDataResponse>(
            "GetLastLoginDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetLastLoginDataResponse {
    const NAME: &'static str = "GetLastLoginDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.errorCode = is.read_int32()?;
                },
                26 => {
                    self.token = is.read_string()?;
                },
                32 => {
                    self.userId = is.read_int32()?;
                },
                42 => {
                    self.email = is.read_string()?;
                },
                48 => {
                    self.isTokenValid = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.errorCode != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.errorCode);
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.token);
        }
        if self.userId != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.userId);
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.email);
        }
        if self.isTokenValid != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.errorCode != 0 {
            os.write_int32(2, self.errorCode)?;
        }
        if !self.token.is_empty() {
            os.write_string(3, &self.token)?;
        }
        if self.userId != 0 {
            os.write_int32(4, self.userId)?;
        }
        if !self.email.is_empty() {
            os.write_string(5, &self.email)?;
        }
        if self.isTokenValid != false {
            os.write_bool(6, self.isTokenValid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLastLoginDataResponse {
        GetLastLoginDataResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.errorCode = 0;
        self.token.clear();
        self.userId = 0;
        self.email.clear();
        self.isTokenValid = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLastLoginDataResponse {
        static instance: GetLastLoginDataResponse = GetLastLoginDataResponse {
            success: false,
            errorCode: 0,
            token: ::std::string::String::new(),
            userId: 0,
            email: ::std::string::String::new(),
            isTokenValid: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetLastLoginDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetLastLoginDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetLastLoginDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLastLoginDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.SearchNotes)
pub struct SearchNotes {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.SearchNotes.query)
    pub query: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.SearchNotes.folderId)
    pub folderId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.SearchNotes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SearchNotes {
    fn default() -> &'a SearchNotes {
        <SearchNotes as ::protobuf::Message>::default_instance()
    }
}

impl SearchNotes {
    pub fn new() -> SearchNotes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &SearchNotes| { &m.query },
            |m: &mut SearchNotes| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "folderId",
            |m: &SearchNotes| { &m.folderId },
            |m: &mut SearchNotes| { &mut m.folderId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SearchNotes>(
            "SearchNotes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SearchNotes {
    const NAME: &'static str = "SearchNotes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.query = is.read_string()?;
                },
                18 => {
                    self.folderId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.folderId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(2, &self.folderId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SearchNotes {
        SearchNotes::new()
    }

    fn clear(&mut self) {
        self.query.clear();
        self.folderId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SearchNotes {
        static instance: SearchNotes = SearchNotes {
            query: ::std::string::String::new(),
            folderId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SearchNotes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SearchNotes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SearchNotes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchNotes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.UpdateFolder)
pub struct UpdateFolder {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.UpdateFolder.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.UpdateFolder.parentId)
    pub parentId: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.UpdateFolder.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.UpdateFolder.level)
    pub level: i32,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.UpdateFolder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateFolder {
    fn default() -> &'a UpdateFolder {
        <UpdateFolder as ::protobuf::Message>::default_instance()
    }
}

impl UpdateFolder {
    pub fn new() -> UpdateFolder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &UpdateFolder| { &m.id },
            |m: &mut UpdateFolder| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "parentId",
            |m: &UpdateFolder| { &m.parentId },
            |m: &mut UpdateFolder| { &mut m.parentId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &UpdateFolder| { &m.title },
            |m: &mut UpdateFolder| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &UpdateFolder| { &m.level },
            |m: &mut UpdateFolder| { &mut m.level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateFolder>(
            "UpdateFolder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateFolder {
    const NAME: &'static str = "UpdateFolder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.parentId = is.read_string()?;
                },
                26 => {
                    self.title = is.read_string()?;
                },
                32 => {
                    self.level = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.parentId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.parentId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.title);
        }
        if self.level != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.parentId.is_empty() {
            os.write_string(2, &self.parentId)?;
        }
        if !self.title.is_empty() {
            os.write_string(3, &self.title)?;
        }
        if self.level != 0 {
            os.write_int32(4, self.level)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateFolder {
        UpdateFolder::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.parentId.clear();
        self.title.clear();
        self.level = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateFolder {
        static instance: UpdateFolder = UpdateFolder {
            id: ::std::string::String::new(),
            parentId: ::std::string::String::new(),
            title: ::std::string::String::new(),
            level: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateFolder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateFolder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateFolder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateFolder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.UpdateNote)
pub struct UpdateNote {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.UpdateNote.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.UpdateNote.folderId)
    pub folderId: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.UpdateNote.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:gigamessages.UpdateNote.text)
    pub text: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.UpdateNote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateNote {
    fn default() -> &'a UpdateNote {
        <UpdateNote as ::protobuf::Message>::default_instance()
    }
}

impl UpdateNote {
    pub fn new() -> UpdateNote {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &UpdateNote| { &m.id },
            |m: &mut UpdateNote| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "folderId",
            |m: &UpdateNote| { &m.folderId },
            |m: &mut UpdateNote| { &mut m.folderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &UpdateNote| { &m.title },
            |m: &mut UpdateNote| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &UpdateNote| { &m.text },
            |m: &mut UpdateNote| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateNote>(
            "UpdateNote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateNote {
    const NAME: &'static str = "UpdateNote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.folderId = is.read_string()?;
                },
                26 => {
                    self.title = is.read_string()?;
                },
                34 => {
                    self.text = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.folderId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.folderId);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.title);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.folderId.is_empty() {
            os.write_string(2, &self.folderId)?;
        }
        if !self.title.is_empty() {
            os.write_string(3, &self.title)?;
        }
        if !self.text.is_empty() {
            os.write_string(4, &self.text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateNote {
        UpdateNote::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.folderId.clear();
        self.title.clear();
        self.text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateNote {
        static instance: UpdateNote = UpdateNote {
            id: ::std::string::String::new(),
            folderId: ::std::string::String::new(),
            title: ::std::string::String::new(),
            text: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateNote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateNote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateNote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateNote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.AddToFavorites)
pub struct AddToFavorites {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.AddToFavorites.noteId)
    pub noteId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.AddToFavorites.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddToFavorites {
    fn default() -> &'a AddToFavorites {
        <AddToFavorites as ::protobuf::Message>::default_instance()
    }
}

impl AddToFavorites {
    pub fn new() -> AddToFavorites {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "noteId",
            |m: &AddToFavorites| { &m.noteId },
            |m: &mut AddToFavorites| { &mut m.noteId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddToFavorites>(
            "AddToFavorites",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddToFavorites {
    const NAME: &'static str = "AddToFavorites";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.noteId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.noteId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.noteId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.noteId.is_empty() {
            os.write_string(1, &self.noteId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddToFavorites {
        AddToFavorites::new()
    }

    fn clear(&mut self) {
        self.noteId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddToFavorites {
        static instance: AddToFavorites = AddToFavorites {
            noteId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddToFavorites {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddToFavorites").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddToFavorites {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddToFavorites {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:gigamessages.RemoveFromFavorites)
pub struct RemoveFromFavorites {
    // message fields
    // @@protoc_insertion_point(field:gigamessages.RemoveFromFavorites.noteId)
    pub noteId: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:gigamessages.RemoveFromFavorites.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveFromFavorites {
    fn default() -> &'a RemoveFromFavorites {
        <RemoveFromFavorites as ::protobuf::Message>::default_instance()
    }
}

impl RemoveFromFavorites {
    pub fn new() -> RemoveFromFavorites {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "noteId",
            |m: &RemoveFromFavorites| { &m.noteId },
            |m: &mut RemoveFromFavorites| { &mut m.noteId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveFromFavorites>(
            "RemoveFromFavorites",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveFromFavorites {
    const NAME: &'static str = "RemoveFromFavorites";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.noteId = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.noteId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.noteId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.noteId.is_empty() {
            os.write_string(1, &self.noteId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveFromFavorites {
        RemoveFromFavorites::new()
    }

    fn clear(&mut self) {
        self.noteId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveFromFavorites {
        static instance: RemoveFromFavorites = RemoveFromFavorites {
            noteId: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveFromFavorites {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveFromFavorites").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveFromFavorites {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveFromFavorites {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15protos/messages.proto\x12\x0cgigamessages\"@\n\x08InitData\x12\x1a\
    \n\x08dataPath\x18\x01\x20\x01(\tR\x08dataPath\x12\x18\n\x07apiPath\x18\
    \x02\x20\x01(\tR\x07apiPath\"9\n\x05Login\x12\x14\n\x05email\x18\x01\x20\
    \x01(\tR\x05email\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\x08password\
    \"U\n\x0bLoginSocial\x12\x14\n\x05email\x18\x01\x20\x01(\tR\x05email\x12\
    \x1a\n\x08provider\x18\x02\x20\x01(\tR\x08provider\x12\x14\n\x05token\
    \x18\x03\x20\x01(\tR\x05token\"u\n\rLoginResponse\x12\x18\n\x07success\
    \x18\x01\x20\x01(\x08R\x07success\x12\x1c\n\terrorCode\x18\x02\x20\x01(\
    \x05R\terrorCode\x12\x14\n\x05token\x18\x03\x20\x01(\tR\x05token\x12\x16\
    \n\x06userId\x18\x04\x20\x01(\x05R\x06userId\"R\n\nCreateNote\x12\x14\n\
    \x05title\x18\x01\x20\x01(\tR\x05title\x12\x12\n\x04text\x18\x02\x20\x01\
    (\tR\x04text\x12\x1a\n\x08folderId\x18\x03\x20\x01(\tR\x08folderId\"@\n\
    \x0cCreateFolder\x12\x1a\n\x08parentId\x18\x01\x20\x01(\tR\x08parentId\
    \x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\"j\n\x14CreateFolderRes\
    ponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\x12\x1c\n\te\
    rrorCode\x18\x02\x20\x01(\x05R\terrorCode\x12\x1a\n\x08folderId\x18\x03\
    \x20\x01(\tR\x08folderId\"d\n\x12CreateNoteResponse\x12\x18\n\x07success\
    \x18\x01\x20\x01(\x08R\x07success\x12\x1c\n\terrorCode\x18\x02\x20\x01(\
    \x05R\terrorCode\x12\x16\n\x06noteId\x18\x03\x20\x01(\tR\x06noteId\"*\n\
    \x0cGetNotesList\x12\x1a\n\x08folderId\x18\x01\x20\x01(\tR\x08folderId\"\
    ;\n\x0bGetAllNotes\x12\x16\n\x06offset\x18\x01\x20\x01(\x05R\x06offset\
    \x12\x14\n\x05limit\x18\x02\x20\x01(\x05R\x05limit\"\x20\n\x08SetToken\
    \x12\x14\n\x05token\x18\x01\x20\x01(\tR\x05token\"\x8d\x01\n\rNoteShortI\
    nfo\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x1a\n\x08folderId\x18\
    \x02\x20\x01(\tR\x08folderId\x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05t\
    itle\x12\x1c\n\tcreatedAt\x18\x04\x20\x01(\x03R\tcreatedAt\x12\x1c\n\tup\
    datedAt\x18\x05\x20\x01(\x03R\tupdatedAt\"\x81\x01\n\x14GetNotesListResp\
    onse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\x12\x1c\n\ter\
    rorCode\x18\x02\x20\x01(\x05R\terrorCode\x121\n\x05notes\x18\x03\x20\x03\
    (\x0b2\x1b.gigamessages.NoteShortInfoR\x05notes\"\x9c\x01\n\x06Folder\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x1a\n\x08parentId\x18\x02\
    \x20\x01(\tR\x08parentId\x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\
    \x12\x14\n\x05level\x18\x04\x20\x01(\x05R\x05level\x12\x1c\n\tcreatedAt\
    \x18\x05\x20\x01(\x03R\tcreatedAt\x12\x1c\n\tupdatedAt\x18\x06\x20\x01(\
    \x03R\tupdatedAt\"\x80\x01\n\x16GetFoldersListResponse\x12\x18\n\x07succ\
    ess\x18\x01\x20\x01(\x08R\x07success\x12\x1c\n\terrorCode\x18\x02\x20\
    \x01(\x05R\terrorCode\x12.\n\x07folders\x18\x03\x20\x03(\x0b2\x14.gigame\
    ssages.FolderR\x07folders\"%\n\x0bGetNoteById\x12\x16\n\x06noteId\x18\
    \x01\x20\x01(\tR\x06noteId\"\xa3\x01\n\x13GetNoteByIdResponse\x12\x18\n\
    \x07success\x18\x01\x20\x01(\x08R\x07success\x12\x1c\n\terrorCode\x18\
    \x02\x20\x01(\x05R\terrorCode\x12\x0e\n\x02id\x18\x03\x20\x01(\tR\x02id\
    \x12\x1a\n\x08folderId\x18\x04\x20\x01(\tR\x08folderId\x12\x14\n\x05titl\
    e\x18\x05\x20\x01(\tR\x05title\x12\x12\n\x04text\x18\x06\x20\x01(\tR\x04\
    text\"+\n\rGetFolderById\x12\x1a\n\x08folderId\x18\x01\x20\x01(\tR\x08fo\
    lderId\"\xe3\x01\n\x15GetFolderByIdResponse\x12\x18\n\x07success\x18\x01\
    \x20\x01(\x08R\x07success\x12\x1c\n\terrorCode\x18\x02\x20\x01(\x05R\ter\
    rorCode\x12\x0e\n\x02id\x18\x03\x20\x01(\tR\x02id\x12\x14\n\x05title\x18\
    \x04\x20\x01(\tR\x05title\x12\x1a\n\x08parentId\x18\x05\x20\x01(\tR\x08p\
    arentId\x12\x14\n\x05level\x18\x06\x20\x01(\x05R\x05level\x12\x1c\n\tcre\
    atedAt\x18\x07\x20\x01(\x03R\tcreatedAt\x12\x1c\n\tupdatedAt\x18\x08\x20\
    \x01(\x03R\tupdatedAt\"$\n\nRemoveNote\x12\x16\n\x06noteId\x18\x01\x20\
    \x01(\tR\x06noteId\"*\n\x0cRemoveFolder\x12\x1a\n\x08folderId\x18\x01\
    \x20\x01(\tR\x08folderId\"\x81\x01\n\x15GetRootFolderResponse\x12\x18\n\
    \x07success\x18\x01\x20\x01(\x08R\x07success\x12\x1c\n\terrorCode\x18\
    \x02\x20\x01(\x05R\terrorCode\x12\x1a\n\x08folderId\x18\x03\x20\x01(\tR\
    \x08folderId\x12\x14\n\x05title\x18\x05\x20\x01(\tR\x05title\"M\n\x13Emp\
    tyResultResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\
    \x12\x1c\n\terrorCode\x18\x02\x20\x01(\x05R\terrorCode\"\xba\x01\n\x18Ge\
    tLastLoginDataResponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07suc\
    cess\x12\x1c\n\terrorCode\x18\x02\x20\x01(\x05R\terrorCode\x12\x14\n\x05\
    token\x18\x03\x20\x01(\tR\x05token\x12\x16\n\x06userId\x18\x04\x20\x01(\
    \x05R\x06userId\x12\x14\n\x05email\x18\x05\x20\x01(\tR\x05email\x12\"\n\
    \x0cisTokenValid\x18\x06\x20\x01(\x08R\x0cisTokenValid\"?\n\x0bSearchNot\
    es\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\x12\x1a\n\x08folderId\
    \x18\x02\x20\x01(\tR\x08folderId\"f\n\x0cUpdateFolder\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12\x1a\n\x08parentId\x18\x02\x20\x01(\tR\x08\
    parentId\x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\x12\x14\n\x05le\
    vel\x18\x04\x20\x01(\x05R\x05level\"b\n\nUpdateNote\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x1a\n\x08folderId\x18\x02\x20\x01(\tR\x08fold\
    erId\x12\x14\n\x05title\x18\x03\x20\x01(\tR\x05title\x12\x12\n\x04text\
    \x18\x04\x20\x01(\tR\x04text\"(\n\x0eAddToFavorites\x12\x16\n\x06noteId\
    \x18\x01\x20\x01(\tR\x06noteId\"-\n\x13RemoveFromFavorites\x12\x16\n\x06\
    noteId\x18\x01\x20\x01(\tR\x06noteIdJ\xac+\n\x07\x12\x05\0\0\xb0\x01\x01\
    \n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x15\n\n\n\
    \x02\x04\0\x12\x04\x04\0\x07\x01\n\n\n\x03\x04\0\x01\x12\x03\x04\x08\x10\
    \n\x0b\n\x04\x04\0\x02\0\x12\x03\x05\x04\x18\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03\x05\x04\n\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x05\x0b\x13\n\x0c\
    \n\x05\x04\0\x02\0\x03\x12\x03\x05\x16\x17\n\x0b\n\x04\x04\0\x02\x01\x12\
    \x03\x06\x04\x17\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x06\x04\n\n\x0c\n\
    \x05\x04\0\x02\x01\x01\x12\x03\x06\x0b\x12\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03\x06\x15\x16\n\n\n\x02\x04\x01\x12\x04\t\0\x0c\x01\n\n\n\x03\x04\
    \x01\x01\x12\x03\t\x08\r\n\x0b\n\x04\x04\x01\x02\0\x12\x03\n\x04\x15\n\
    \x0c\n\x05\x04\x01\x02\0\x05\x12\x03\n\x04\n\n\x0c\n\x05\x04\x01\x02\0\
    \x01\x12\x03\n\x0b\x10\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\n\x13\x14\n\
    \x0b\n\x04\x04\x01\x02\x01\x12\x03\x0b\x04\x18\n\x0c\n\x05\x04\x01\x02\
    \x01\x05\x12\x03\x0b\x04\n\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\x0b\
    \x0b\x13\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x0b\x16\x17\n\n\n\x02\
    \x04\x02\x12\x04\x0e\0\x12\x01\n\n\n\x03\x04\x02\x01\x12\x03\x0e\x08\x13\
    \n\x0b\n\x04\x04\x02\x02\0\x12\x03\x0f\x04\x15\n\x0c\n\x05\x04\x02\x02\0\
    \x05\x12\x03\x0f\x04\n\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x0f\x0b\x10\
    \n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x0f\x13\x14\n\x0b\n\x04\x04\x02\
    \x02\x01\x12\x03\x10\x04\x18\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x10\
    \x04\n\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\x10\x0b\x13\n\x0c\n\x05\
    \x04\x02\x02\x01\x03\x12\x03\x10\x16\x17\n\x0b\n\x04\x04\x02\x02\x02\x12\
    \x03\x11\x04\x15\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03\x11\x04\n\n\x0c\
    \n\x05\x04\x02\x02\x02\x01\x12\x03\x11\x0b\x10\n\x0c\n\x05\x04\x02\x02\
    \x02\x03\x12\x03\x11\x13\x14\n\n\n\x02\x04\x03\x12\x04\x14\0\x19\x01\n\n\
    \n\x03\x04\x03\x01\x12\x03\x14\x08\x15\n\x0b\n\x04\x04\x03\x02\0\x12\x03\
    \x15\x04\x15\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03\x15\x04\x08\n\x0c\n\
    \x05\x04\x03\x02\0\x01\x12\x03\x15\t\x10\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03\x15\x13\x14\n\x0b\n\x04\x04\x03\x02\x01\x12\x03\x16\x04\x18\n\
    \x0c\n\x05\x04\x03\x02\x01\x05\x12\x03\x16\x04\t\n\x0c\n\x05\x04\x03\x02\
    \x01\x01\x12\x03\x16\n\x13\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03\x16\
    \x16\x17\n\x0b\n\x04\x04\x03\x02\x02\x12\x03\x17\x04\x15\n\x0c\n\x05\x04\
    \x03\x02\x02\x05\x12\x03\x17\x04\n\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\
    \x03\x17\x0b\x10\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03\x17\x13\x14\n\
    \x0b\n\x04\x04\x03\x02\x03\x12\x03\x18\x04\x15\n\x0c\n\x05\x04\x03\x02\
    \x03\x05\x12\x03\x18\x04\t\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03\x18\n\
    \x10\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03\x18\x13\x14\n\n\n\x02\x04\
    \x04\x12\x04\x1c\0\x20\x01\n\n\n\x03\x04\x04\x01\x12\x03\x1c\x08\x12\n\
    \x0b\n\x04\x04\x04\x02\0\x12\x03\x1d\x04\x15\n\x0c\n\x05\x04\x04\x02\0\
    \x05\x12\x03\x1d\x04\n\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03\x1d\x0b\x10\
    \n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03\x1d\x13\x14\n\x0b\n\x04\x04\x04\
    \x02\x01\x12\x03\x1e\x04\x14\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03\x1e\
    \x04\n\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03\x1e\x0b\x0f\n\x0c\n\x05\
    \x04\x04\x02\x01\x03\x12\x03\x1e\x12\x13\n\x0b\n\x04\x04\x04\x02\x02\x12\
    \x03\x1f\x04\x18\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03\x1f\x04\n\n\x0c\
    \n\x05\x04\x04\x02\x02\x01\x12\x03\x1f\x0b\x13\n\x0c\n\x05\x04\x04\x02\
    \x02\x03\x12\x03\x1f\x16\x17\n\n\n\x02\x04\x05\x12\x04\"\0%\x01\n\n\n\
    \x03\x04\x05\x01\x12\x03\"\x08\x14\n\x0b\n\x04\x04\x05\x02\0\x12\x03#\
    \x04\x18\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03#\x04\n\n\x0c\n\x05\x04\
    \x05\x02\0\x01\x12\x03#\x0b\x13\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03#\
    \x16\x17\n\x0b\n\x04\x04\x05\x02\x01\x12\x03$\x04\x15\n\x0c\n\x05\x04\
    \x05\x02\x01\x05\x12\x03$\x04\n\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03$\
    \x0b\x10\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03$\x13\x14\n\n\n\x02\x04\
    \x06\x12\x04'\0+\x01\n\n\n\x03\x04\x06\x01\x12\x03'\x08\x1c\n\x0b\n\x04\
    \x04\x06\x02\0\x12\x03(\x04\x15\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03(\
    \x04\x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03(\t\x10\n\x0c\n\x05\x04\
    \x06\x02\0\x03\x12\x03(\x13\x14\n\x0b\n\x04\x04\x06\x02\x01\x12\x03)\x04\
    \x18\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03)\x04\t\n\x0c\n\x05\x04\x06\
    \x02\x01\x01\x12\x03)\n\x13\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03)\x16\
    \x17\n\x0b\n\x04\x04\x06\x02\x02\x12\x03*\x04\x18\n\x0c\n\x05\x04\x06\
    \x02\x02\x05\x12\x03*\x04\n\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03*\x0b\
    \x13\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03*\x16\x17\n\n\n\x02\x04\x07\
    \x12\x04-\01\x01\n\n\n\x03\x04\x07\x01\x12\x03-\x08\x1a\n\x0b\n\x04\x04\
    \x07\x02\0\x12\x03.\x04\x15\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03.\x04\
    \x08\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03.\t\x10\n\x0c\n\x05\x04\x07\
    \x02\0\x03\x12\x03.\x13\x14\n\x0b\n\x04\x04\x07\x02\x01\x12\x03/\x04\x18\
    \n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03/\x04\t\n\x0c\n\x05\x04\x07\x02\
    \x01\x01\x12\x03/\n\x13\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03/\x16\x17\
    \n\x0b\n\x04\x04\x07\x02\x02\x12\x030\x04\x16\n\x0c\n\x05\x04\x07\x02\
    \x02\x05\x12\x030\x04\n\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x030\x0b\x11\
    \n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x030\x14\x15\n\n\n\x02\x04\x08\x12\
    \x043\05\x01\n\n\n\x03\x04\x08\x01\x12\x033\x08\x14\n\x0b\n\x04\x04\x08\
    \x02\0\x12\x034\x04\x18\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x034\x04\n\n\
    \x0c\n\x05\x04\x08\x02\0\x01\x12\x034\x0b\x13\n\x0c\n\x05\x04\x08\x02\0\
    \x03\x12\x034\x16\x17\n\n\n\x02\x04\t\x12\x047\0:\x01\n\n\n\x03\x04\t\
    \x01\x12\x037\x08\x13\n\x0b\n\x04\x04\t\x02\0\x12\x038\x04\x15\n\x0c\n\
    \x05\x04\t\x02\0\x05\x12\x038\x04\t\n\x0c\n\x05\x04\t\x02\0\x01\x12\x038\
    \n\x10\n\x0c\n\x05\x04\t\x02\0\x03\x12\x038\x13\x14\n\x0b\n\x04\x04\t\
    \x02\x01\x12\x039\x04\x14\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x039\x04\t\n\
    \x0c\n\x05\x04\t\x02\x01\x01\x12\x039\n\x0f\n\x0c\n\x05\x04\t\x02\x01\
    \x03\x12\x039\x12\x13\n\n\n\x02\x04\n\x12\x04<\0>\x01\n\n\n\x03\x04\n\
    \x01\x12\x03<\x08\x10\n\x0b\n\x04\x04\n\x02\0\x12\x03=\x04\x15\n\x0c\n\
    \x05\x04\n\x02\0\x05\x12\x03=\x04\n\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03=\
    \x0b\x10\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03=\x13\x14\n\n\n\x02\x04\x0b\
    \x12\x04@\0F\x01\n\n\n\x03\x04\x0b\x01\x12\x03@\x08\x15\n\x0b\n\x04\x04\
    \x0b\x02\0\x12\x03A\x04\x12\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03A\x04\n\
    \n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03A\x0b\r\n\x0c\n\x05\x04\x0b\x02\0\
    \x03\x12\x03A\x10\x11\n\x0b\n\x04\x04\x0b\x02\x01\x12\x03B\x04\x18\n\x0c\
    \n\x05\x04\x0b\x02\x01\x05\x12\x03B\x04\n\n\x0c\n\x05\x04\x0b\x02\x01\
    \x01\x12\x03B\x0b\x13\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03B\x16\x17\n\
    \x0b\n\x04\x04\x0b\x02\x02\x12\x03C\x04\x15\n\x0c\n\x05\x04\x0b\x02\x02\
    \x05\x12\x03C\x04\n\n\x0c\n\x05\x04\x0b\x02\x02\x01\x12\x03C\x0b\x10\n\
    \x0c\n\x05\x04\x0b\x02\x02\x03\x12\x03C\x13\x14\n\x0b\n\x04\x04\x0b\x02\
    \x03\x12\x03D\x04\x18\n\x0c\n\x05\x04\x0b\x02\x03\x05\x12\x03D\x04\t\n\
    \x0c\n\x05\x04\x0b\x02\x03\x01\x12\x03D\n\x13\n\x0c\n\x05\x04\x0b\x02\
    \x03\x03\x12\x03D\x16\x17\n\x0b\n\x04\x04\x0b\x02\x04\x12\x03E\x04\x18\n\
    \x0c\n\x05\x04\x0b\x02\x04\x05\x12\x03E\x04\t\n\x0c\n\x05\x04\x0b\x02\
    \x04\x01\x12\x03E\n\x13\n\x0c\n\x05\x04\x0b\x02\x04\x03\x12\x03E\x16\x17\
    \n\n\n\x02\x04\x0c\x12\x04H\0L\x01\n\n\n\x03\x04\x0c\x01\x12\x03H\x08\
    \x1c\n\x0b\n\x04\x04\x0c\x02\0\x12\x03I\x04\x15\n\x0c\n\x05\x04\x0c\x02\
    \0\x05\x12\x03I\x04\x08\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03I\t\x10\n\
    \x0c\n\x05\x04\x0c\x02\0\x03\x12\x03I\x13\x14\n\x0b\n\x04\x04\x0c\x02\
    \x01\x12\x03J\x04\x18\n\x0c\n\x05\x04\x0c\x02\x01\x05\x12\x03J\x04\t\n\
    \x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03J\n\x13\n\x0c\n\x05\x04\x0c\x02\
    \x01\x03\x12\x03J\x16\x17\n\x0b\n\x04\x04\x0c\x02\x02\x12\x03K\x04%\n\
    \x0c\n\x05\x04\x0c\x02\x02\x04\x12\x03K\x04\x0c\n\x0c\n\x05\x04\x0c\x02\
    \x02\x06\x12\x03K\r\x1a\n\x0c\n\x05\x04\x0c\x02\x02\x01\x12\x03K\x1b\x20\
    \n\x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03K#$\n\n\n\x02\x04\r\x12\x04N\0U\
    \x01\n\n\n\x03\x04\r\x01\x12\x03N\x08\x0e\n\x0b\n\x04\x04\r\x02\0\x12\
    \x03O\x04\x12\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03O\x04\n\n\x0c\n\x05\x04\
    \r\x02\0\x01\x12\x03O\x0b\r\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03O\x10\x11\
    \n\x0b\n\x04\x04\r\x02\x01\x12\x03P\x04\x18\n\x0c\n\x05\x04\r\x02\x01\
    \x05\x12\x03P\x04\n\n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03P\x0b\x13\n\x0c\
    \n\x05\x04\r\x02\x01\x03\x12\x03P\x16\x17\n\x0b\n\x04\x04\r\x02\x02\x12\
    \x03Q\x04\x15\n\x0c\n\x05\x04\r\x02\x02\x05\x12\x03Q\x04\n\n\x0c\n\x05\
    \x04\r\x02\x02\x01\x12\x03Q\x0b\x10\n\x0c\n\x05\x04\r\x02\x02\x03\x12\
    \x03Q\x13\x14\n\x0b\n\x04\x04\r\x02\x03\x12\x03R\x04\x14\n\x0c\n\x05\x04\
    \r\x02\x03\x05\x12\x03R\x04\t\n\x0c\n\x05\x04\r\x02\x03\x01\x12\x03R\n\
    \x0f\n\x0c\n\x05\x04\r\x02\x03\x03\x12\x03R\x12\x13\n\x0b\n\x04\x04\r\
    \x02\x04\x12\x03S\x04\x18\n\x0c\n\x05\x04\r\x02\x04\x05\x12\x03S\x04\t\n\
    \x0c\n\x05\x04\r\x02\x04\x01\x12\x03S\n\x13\n\x0c\n\x05\x04\r\x02\x04\
    \x03\x12\x03S\x16\x17\n\x0b\n\x04\x04\r\x02\x05\x12\x03T\x04\x18\n\x0c\n\
    \x05\x04\r\x02\x05\x05\x12\x03T\x04\t\n\x0c\n\x05\x04\r\x02\x05\x01\x12\
    \x03T\n\x13\n\x0c\n\x05\x04\r\x02\x05\x03\x12\x03T\x16\x17\n\n\n\x02\x04\
    \x0e\x12\x04W\0[\x01\n\n\n\x03\x04\x0e\x01\x12\x03W\x08\x1e\n\x0b\n\x04\
    \x04\x0e\x02\0\x12\x03X\x04\x15\n\x0c\n\x05\x04\x0e\x02\0\x05\x12\x03X\
    \x04\x08\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03X\t\x10\n\x0c\n\x05\x04\
    \x0e\x02\0\x03\x12\x03X\x13\x14\n\x0b\n\x04\x04\x0e\x02\x01\x12\x03Y\x04\
    \x18\n\x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03Y\x04\t\n\x0c\n\x05\x04\x0e\
    \x02\x01\x01\x12\x03Y\n\x13\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\x03Y\x16\
    \x17\n\x0b\n\x04\x04\x0e\x02\x02\x12\x03Z\x04\x20\n\x0c\n\x05\x04\x0e\
    \x02\x02\x04\x12\x03Z\x04\x0c\n\x0c\n\x05\x04\x0e\x02\x02\x06\x12\x03Z\r\
    \x13\n\x0c\n\x05\x04\x0e\x02\x02\x01\x12\x03Z\x14\x1b\n\x0c\n\x05\x04\
    \x0e\x02\x02\x03\x12\x03Z\x1e\x1f\n\n\n\x02\x04\x0f\x12\x04]\0_\x01\n\n\
    \n\x03\x04\x0f\x01\x12\x03]\x08\x13\n\x0b\n\x04\x04\x0f\x02\0\x12\x03^\
    \x04\x16\n\x0c\n\x05\x04\x0f\x02\0\x05\x12\x03^\x04\n\n\x0c\n\x05\x04\
    \x0f\x02\0\x01\x12\x03^\x0b\x11\n\x0c\n\x05\x04\x0f\x02\0\x03\x12\x03^\
    \x14\x15\n\n\n\x02\x04\x10\x12\x04a\0h\x01\n\n\n\x03\x04\x10\x01\x12\x03\
    a\x08\x1b\n\x0b\n\x04\x04\x10\x02\0\x12\x03b\x04\x15\n\x0c\n\x05\x04\x10\
    \x02\0\x05\x12\x03b\x04\x08\n\x0c\n\x05\x04\x10\x02\0\x01\x12\x03b\t\x10\
    \n\x0c\n\x05\x04\x10\x02\0\x03\x12\x03b\x13\x14\n\x0b\n\x04\x04\x10\x02\
    \x01\x12\x03c\x04\x18\n\x0c\n\x05\x04\x10\x02\x01\x05\x12\x03c\x04\t\n\
    \x0c\n\x05\x04\x10\x02\x01\x01\x12\x03c\n\x13\n\x0c\n\x05\x04\x10\x02\
    \x01\x03\x12\x03c\x16\x17\n\x0b\n\x04\x04\x10\x02\x02\x12\x03d\x04\x12\n\
    \x0c\n\x05\x04\x10\x02\x02\x05\x12\x03d\x04\n\n\x0c\n\x05\x04\x10\x02\
    \x02\x01\x12\x03d\x0b\r\n\x0c\n\x05\x04\x10\x02\x02\x03\x12\x03d\x10\x11\
    \n\x0b\n\x04\x04\x10\x02\x03\x12\x03e\x04\x18\n\x0c\n\x05\x04\x10\x02\
    \x03\x05\x12\x03e\x04\n\n\x0c\n\x05\x04\x10\x02\x03\x01\x12\x03e\x0b\x13\
    \n\x0c\n\x05\x04\x10\x02\x03\x03\x12\x03e\x16\x17\n\x0b\n\x04\x04\x10\
    \x02\x04\x12\x03f\x04\x15\n\x0c\n\x05\x04\x10\x02\x04\x05\x12\x03f\x04\n\
    \n\x0c\n\x05\x04\x10\x02\x04\x01\x12\x03f\x0b\x10\n\x0c\n\x05\x04\x10\
    \x02\x04\x03\x12\x03f\x13\x14\n\x0b\n\x04\x04\x10\x02\x05\x12\x03g\x04\
    \x14\n\x0c\n\x05\x04\x10\x02\x05\x05\x12\x03g\x04\n\n\x0c\n\x05\x04\x10\
    \x02\x05\x01\x12\x03g\x0b\x0f\n\x0c\n\x05\x04\x10\x02\x05\x03\x12\x03g\
    \x12\x13\n\n\n\x02\x04\x11\x12\x04j\0l\x01\n\n\n\x03\x04\x11\x01\x12\x03\
    j\x08\x15\n\x0b\n\x04\x04\x11\x02\0\x12\x03k\x04\x18\n\x0c\n\x05\x04\x11\
    \x02\0\x05\x12\x03k\x04\n\n\x0c\n\x05\x04\x11\x02\0\x01\x12\x03k\x0b\x13\
    \n\x0c\n\x05\x04\x11\x02\0\x03\x12\x03k\x16\x17\n\n\n\x02\x04\x12\x12\
    \x04n\0w\x01\n\n\n\x03\x04\x12\x01\x12\x03n\x08\x1d\n\x0b\n\x04\x04\x12\
    \x02\0\x12\x03o\x04\x15\n\x0c\n\x05\x04\x12\x02\0\x05\x12\x03o\x04\x08\n\
    \x0c\n\x05\x04\x12\x02\0\x01\x12\x03o\t\x10\n\x0c\n\x05\x04\x12\x02\0\
    \x03\x12\x03o\x13\x14\n\x0b\n\x04\x04\x12\x02\x01\x12\x03p\x04\x18\n\x0c\
    \n\x05\x04\x12\x02\x01\x05\x12\x03p\x04\t\n\x0c\n\x05\x04\x12\x02\x01\
    \x01\x12\x03p\n\x13\n\x0c\n\x05\x04\x12\x02\x01\x03\x12\x03p\x16\x17\n\
    \x0b\n\x04\x04\x12\x02\x02\x12\x03q\x04\x12\n\x0c\n\x05\x04\x12\x02\x02\
    \x05\x12\x03q\x04\n\n\x0c\n\x05\x04\x12\x02\x02\x01\x12\x03q\x0b\r\n\x0c\
    \n\x05\x04\x12\x02\x02\x03\x12\x03q\x10\x11\n\x0b\n\x04\x04\x12\x02\x03\
    \x12\x03r\x04\x15\n\x0c\n\x05\x04\x12\x02\x03\x05\x12\x03r\x04\n\n\x0c\n\
    \x05\x04\x12\x02\x03\x01\x12\x03r\x0b\x10\n\x0c\n\x05\x04\x12\x02\x03\
    \x03\x12\x03r\x13\x14\n\x0b\n\x04\x04\x12\x02\x04\x12\x03s\x04\x18\n\x0c\
    \n\x05\x04\x12\x02\x04\x05\x12\x03s\x04\n\n\x0c\n\x05\x04\x12\x02\x04\
    \x01\x12\x03s\x0b\x13\n\x0c\n\x05\x04\x12\x02\x04\x03\x12\x03s\x16\x17\n\
    \x0b\n\x04\x04\x12\x02\x05\x12\x03t\x04\x14\n\x0c\n\x05\x04\x12\x02\x05\
    \x05\x12\x03t\x04\t\n\x0c\n\x05\x04\x12\x02\x05\x01\x12\x03t\n\x0f\n\x0c\
    \n\x05\x04\x12\x02\x05\x03\x12\x03t\x12\x13\n\x0b\n\x04\x04\x12\x02\x06\
    \x12\x03u\x04\x18\n\x0c\n\x05\x04\x12\x02\x06\x05\x12\x03u\x04\t\n\x0c\n\
    \x05\x04\x12\x02\x06\x01\x12\x03u\n\x13\n\x0c\n\x05\x04\x12\x02\x06\x03\
    \x12\x03u\x16\x17\n\x0b\n\x04\x04\x12\x02\x07\x12\x03v\x04\x18\n\x0c\n\
    \x05\x04\x12\x02\x07\x05\x12\x03v\x04\t\n\x0c\n\x05\x04\x12\x02\x07\x01\
    \x12\x03v\n\x13\n\x0c\n\x05\x04\x12\x02\x07\x03\x12\x03v\x16\x17\n\n\n\
    \x02\x04\x13\x12\x04y\0{\x01\n\n\n\x03\x04\x13\x01\x12\x03y\x08\x12\n\
    \x0b\n\x04\x04\x13\x02\0\x12\x03z\x04\x16\n\x0c\n\x05\x04\x13\x02\0\x05\
    \x12\x03z\x04\n\n\x0c\n\x05\x04\x13\x02\0\x01\x12\x03z\x0b\x11\n\x0c\n\
    \x05\x04\x13\x02\0\x03\x12\x03z\x14\x15\n\n\n\x02\x04\x14\x12\x04}\0\x7f\
    \x01\n\n\n\x03\x04\x14\x01\x12\x03}\x08\x14\n\x0b\n\x04\x04\x14\x02\0\
    \x12\x03~\x04\x18\n\x0c\n\x05\x04\x14\x02\0\x05\x12\x03~\x04\n\n\x0c\n\
    \x05\x04\x14\x02\0\x01\x12\x03~\x0b\x13\n\x0c\n\x05\x04\x14\x02\0\x03\
    \x12\x03~\x16\x17\n\x0c\n\x02\x04\x15\x12\x06\x82\x01\0\x87\x01\x01\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\x82\x01\x08\x1d\n\x0c\n\x04\x04\x15\x02\0\
    \x12\x04\x83\x01\x04\x15\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x83\x01\x04\
    \x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x83\x01\t\x10\n\r\n\x05\x04\x15\
    \x02\0\x03\x12\x04\x83\x01\x13\x14\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\
    \x84\x01\x04\x18\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\x84\x01\x04\t\n\r\
    \n\x05\x04\x15\x02\x01\x01\x12\x04\x84\x01\n\x13\n\r\n\x05\x04\x15\x02\
    \x01\x03\x12\x04\x84\x01\x16\x17\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\x85\
    \x01\x04\x18\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\x85\x01\x04\n\n\r\n\
    \x05\x04\x15\x02\x02\x01\x12\x04\x85\x01\x0b\x13\n\r\n\x05\x04\x15\x02\
    \x02\x03\x12\x04\x85\x01\x16\x17\n\x0c\n\x04\x04\x15\x02\x03\x12\x04\x86\
    \x01\x04\x15\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\x86\x01\x04\n\n\r\n\
    \x05\x04\x15\x02\x03\x01\x12\x04\x86\x01\x0b\x10\n\r\n\x05\x04\x15\x02\
    \x03\x03\x12\x04\x86\x01\x13\x14\n\x0c\n\x02\x04\x16\x12\x06\x89\x01\0\
    \x8c\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\x89\x01\x08\x1b\n\x0c\n\x04\
    \x04\x16\x02\0\x12\x04\x8a\x01\x04\x15\n\r\n\x05\x04\x16\x02\0\x05\x12\
    \x04\x8a\x01\x04\x08\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x8a\x01\t\x10\n\
    \r\n\x05\x04\x16\x02\0\x03\x12\x04\x8a\x01\x13\x14\n\x0c\n\x04\x04\x16\
    \x02\x01\x12\x04\x8b\x01\x04\x18\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\
    \x8b\x01\x04\t\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\x8b\x01\n\x13\n\r\n\
    \x05\x04\x16\x02\x01\x03\x12\x04\x8b\x01\x16\x17\n\x0c\n\x02\x04\x17\x12\
    \x06\x8e\x01\0\x95\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\x8e\x01\x08\
    \x20\n\x0c\n\x04\x04\x17\x02\0\x12\x04\x8f\x01\x04\x15\n\r\n\x05\x04\x17\
    \x02\0\x05\x12\x04\x8f\x01\x04\x08\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\
    \x8f\x01\t\x10\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x8f\x01\x13\x14\n\x0c\
    \n\x04\x04\x17\x02\x01\x12\x04\x90\x01\x04\x18\n\r\n\x05\x04\x17\x02\x01\
    \x05\x12\x04\x90\x01\x04\t\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\x90\x01\
    \n\x13\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\x90\x01\x16\x17\n\x0c\n\x04\
    \x04\x17\x02\x02\x12\x04\x91\x01\x04\x15\n\r\n\x05\x04\x17\x02\x02\x05\
    \x12\x04\x91\x01\x04\n\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\x91\x01\x0b\
    \x10\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\x91\x01\x13\x14\n\x0c\n\x04\
    \x04\x17\x02\x03\x12\x04\x92\x01\x04\x15\n\r\n\x05\x04\x17\x02\x03\x05\
    \x12\x04\x92\x01\x04\t\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\x92\x01\n\
    \x10\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\x92\x01\x13\x14\n\x0c\n\x04\
    \x04\x17\x02\x04\x12\x04\x93\x01\x04\x15\n\r\n\x05\x04\x17\x02\x04\x05\
    \x12\x04\x93\x01\x04\n\n\r\n\x05\x04\x17\x02\x04\x01\x12\x04\x93\x01\x0b\
    \x10\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\x93\x01\x13\x14\n\x0c\n\x04\
    \x04\x17\x02\x05\x12\x04\x94\x01\x04\x1a\n\r\n\x05\x04\x17\x02\x05\x05\
    \x12\x04\x94\x01\x04\x08\n\r\n\x05\x04\x17\x02\x05\x01\x12\x04\x94\x01\t\
    \x15\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\x94\x01\x18\x19\n\x0c\n\x02\
    \x04\x18\x12\x06\x97\x01\0\x9a\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \x97\x01\x08\x13\n\x0c\n\x04\x04\x18\x02\0\x12\x04\x98\x01\x04\x15\n\r\n\
    \x05\x04\x18\x02\0\x05\x12\x04\x98\x01\x04\n\n\r\n\x05\x04\x18\x02\0\x01\
    \x12\x04\x98\x01\x0b\x10\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x98\x01\x13\
    \x14\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\x99\x01\x04\x18\n\r\n\x05\x04\
    \x18\x02\x01\x05\x12\x04\x99\x01\x04\n\n\r\n\x05\x04\x18\x02\x01\x01\x12\
    \x04\x99\x01\x0b\x13\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\x99\x01\x16\
    \x17\n\x0c\n\x02\x04\x19\x12\x06\x9c\x01\0\xa1\x01\x01\n\x0b\n\x03\x04\
    \x19\x01\x12\x04\x9c\x01\x08\x14\n\x0c\n\x04\x04\x19\x02\0\x12\x04\x9d\
    \x01\x04\x12\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\x9d\x01\x04\n\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\x9d\x01\x0b\r\n\r\n\x05\x04\x19\x02\0\x03\x12\
    \x04\x9d\x01\x10\x11\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\x9e\x01\x04\x18\
    \n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\x9e\x01\x04\n\n\r\n\x05\x04\x19\
    \x02\x01\x01\x12\x04\x9e\x01\x0b\x13\n\r\n\x05\x04\x19\x02\x01\x03\x12\
    \x04\x9e\x01\x16\x17\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\x9f\x01\x04\x15\
    \n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\x9f\x01\x04\n\n\r\n\x05\x04\x19\
    \x02\x02\x01\x12\x04\x9f\x01\x0b\x10\n\r\n\x05\x04\x19\x02\x02\x03\x12\
    \x04\x9f\x01\x13\x14\n\x0c\n\x04\x04\x19\x02\x03\x12\x04\xa0\x01\x04\x14\
    \n\r\n\x05\x04\x19\x02\x03\x05\x12\x04\xa0\x01\x04\t\n\r\n\x05\x04\x19\
    \x02\x03\x01\x12\x04\xa0\x01\n\x0f\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\
    \xa0\x01\x12\x13\n\x0c\n\x02\x04\x1a\x12\x06\xa3\x01\0\xa8\x01\x01\n\x0b\
    \n\x03\x04\x1a\x01\x12\x04\xa3\x01\x08\x12\n\x0c\n\x04\x04\x1a\x02\0\x12\
    \x04\xa4\x01\x04\x12\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xa4\x01\x04\n\n\
    \r\n\x05\x04\x1a\x02\0\x01\x12\x04\xa4\x01\x0b\r\n\r\n\x05\x04\x1a\x02\0\
    \x03\x12\x04\xa4\x01\x10\x11\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xa5\x01\
    \x04\x18\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\xa5\x01\x04\n\n\r\n\x05\
    \x04\x1a\x02\x01\x01\x12\x04\xa5\x01\x0b\x13\n\r\n\x05\x04\x1a\x02\x01\
    \x03\x12\x04\xa5\x01\x16\x17\n\x0c\n\x04\x04\x1a\x02\x02\x12\x04\xa6\x01\
    \x04\x15\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xa6\x01\x04\n\n\r\n\x05\
    \x04\x1a\x02\x02\x01\x12\x04\xa6\x01\x0b\x10\n\r\n\x05\x04\x1a\x02\x02\
    \x03\x12\x04\xa6\x01\x13\x14\n\x0c\n\x04\x04\x1a\x02\x03\x12\x04\xa7\x01\
    \x04\x14\n\r\n\x05\x04\x1a\x02\x03\x05\x12\x04\xa7\x01\x04\n\n\r\n\x05\
    \x04\x1a\x02\x03\x01\x12\x04\xa7\x01\x0b\x0f\n\r\n\x05\x04\x1a\x02\x03\
    \x03\x12\x04\xa7\x01\x12\x13\n\x0c\n\x02\x04\x1b\x12\x06\xaa\x01\0\xac\
    \x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xaa\x01\x08\x16\n\x0c\n\x04\x04\
    \x1b\x02\0\x12\x04\xab\x01\x04\x16\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\
    \xab\x01\x04\n\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xab\x01\x0b\x11\n\r\n\
    \x05\x04\x1b\x02\0\x03\x12\x04\xab\x01\x14\x15\n\x0c\n\x02\x04\x1c\x12\
    \x06\xae\x01\0\xb0\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xae\x01\x08\
    \x1b\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xaf\x01\x04\x16\n\r\n\x05\x04\x1c\
    \x02\0\x05\x12\x04\xaf\x01\x04\n\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xaf\
    \x01\x0b\x11\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xaf\x01\x14\x15b\x06pro\
    to3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(29);
            messages.push(InitData::generated_message_descriptor_data());
            messages.push(Login::generated_message_descriptor_data());
            messages.push(LoginSocial::generated_message_descriptor_data());
            messages.push(LoginResponse::generated_message_descriptor_data());
            messages.push(CreateNote::generated_message_descriptor_data());
            messages.push(CreateFolder::generated_message_descriptor_data());
            messages.push(CreateFolderResponse::generated_message_descriptor_data());
            messages.push(CreateNoteResponse::generated_message_descriptor_data());
            messages.push(GetNotesList::generated_message_descriptor_data());
            messages.push(GetAllNotes::generated_message_descriptor_data());
            messages.push(SetToken::generated_message_descriptor_data());
            messages.push(NoteShortInfo::generated_message_descriptor_data());
            messages.push(GetNotesListResponse::generated_message_descriptor_data());
            messages.push(Folder::generated_message_descriptor_data());
            messages.push(GetFoldersListResponse::generated_message_descriptor_data());
            messages.push(GetNoteById::generated_message_descriptor_data());
            messages.push(GetNoteByIdResponse::generated_message_descriptor_data());
            messages.push(GetFolderById::generated_message_descriptor_data());
            messages.push(GetFolderByIdResponse::generated_message_descriptor_data());
            messages.push(RemoveNote::generated_message_descriptor_data());
            messages.push(RemoveFolder::generated_message_descriptor_data());
            messages.push(GetRootFolderResponse::generated_message_descriptor_data());
            messages.push(EmptyResultResponse::generated_message_descriptor_data());
            messages.push(GetLastLoginDataResponse::generated_message_descriptor_data());
            messages.push(SearchNotes::generated_message_descriptor_data());
            messages.push(UpdateFolder::generated_message_descriptor_data());
            messages.push(UpdateNote::generated_message_descriptor_data());
            messages.push(AddToFavorites::generated_message_descriptor_data());
            messages.push(RemoveFromFavorites::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
